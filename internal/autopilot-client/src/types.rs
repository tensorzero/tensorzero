//! Wire types for the TensorZero Autopilot API.
//!
//! These types are shared between the client and server.

use std::collections::HashMap;

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
// Re-export types from tensorzero-types that InputMessage depends on
use schemars::JsonSchema;
pub use tensorzero_types::{
    Base64File, File, InputMessage, InputMessageContent, ObjectStoragePointer, RawText, Role,
    Template, Text, Thought, ToolCallWrapper, Unknown, UrlFile,
};
use uuid::Uuid;

// =============================================================================
// Core Types
// =============================================================================

/// A session representing an autopilot conversation.
#[derive(Debug, Clone, Serialize, Deserialize, ts_rs::TS)]
#[ts(export)]
pub struct Session {
    pub id: Uuid,
    pub organization_id: String,
    pub workspace_id: String,
    pub deployment_id: String,
    pub tensorzero_version: String,
    pub created_at: DateTime<Utc>,
}

/// An event within a session.
#[derive(Debug, Clone, Serialize, Deserialize, ts_rs::TS)]
#[ts(export)]
pub struct Event {
    pub id: Uuid,
    pub payload: EventPayload,
    pub session_id: Uuid,
    pub created_at: DateTime<Utc>,
}

/// The UX-relevant status of the Autopilot.
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, ts_rs::TS)]
#[ts(export)]
#[serde(tag = "status", rename_all = "snake_case")]
pub enum AutopilotStatus {
    Idle,
    ServerSideProcessing,
    WaitingForToolCallAuthorization,
    WaitingForToolExecution,
    WaitingForRetry,
    Failed,
}

#[derive(Debug, Clone, Serialize, Deserialize, ts_rs::TS)]
#[ts(export)]
pub struct StreamUpdate {
    pub event: Event,
    pub status: AutopilotStatus,
}

/// The payload of an event.
#[derive(Clone, Debug, Deserialize, Serialize, ts_rs::TS)]
#[serde(tag = "type", rename_all = "snake_case")]
#[ts(export, tag = "type", rename_all = "snake_case")]
pub enum EventPayload {
    Message(InputMessage),
    Error {
        message: String,
    },
    StatusUpdate {
        status_update: StatusUpdate,
    },
    ToolCall(AutopilotToolCall),
    ToolCallAuthorization(ToolCallAuthorization),
    ToolResult {
        tool_call_event_id: Uuid,
        outcome: ToolOutcome,
    },
    #[serde(other)]
    Other,
}

impl EventPayload {
    /// Returns true if this payload type can be written by API clients.
    /// System-generated types (StatusUpdate, ToolCall) return false.
    pub fn is_client_writable(&self) -> bool {
        matches!(self, EventPayload::Message(msg) if msg.role == Role::User)
            || matches!(
                self,
                EventPayload::ToolCallAuthorization(_) | EventPayload::ToolResult { .. }
            )
    }
}

/// A status update within a session.
#[derive(Clone, Debug, Deserialize, Serialize, ts_rs::TS)]
#[serde(tag = "type", rename_all = "snake_case")]
#[ts(export, tag = "type", rename_all = "snake_case")]
pub enum StatusUpdate {
    Text { text: String },
}

// =============================================================================
// Tool Call Types
// =============================================================================

/// Autopilot tool call with side info for tool execution.
///
/// This extends the interface of a standard tool call with bookkeeping information that
/// allows the caller to send over non-llm generated parameters.
#[derive(Debug, Clone, Serialize, Deserialize, ts_rs::TS)]
pub struct AutopilotToolCall {
    /// Name
    pub name: String,
    /// Arguments
    pub arguments: serde_json::Value,
    /// Side info to pass to the tool (hidden from LLM, used for execution context).
    pub side_info: AutopilotSideInfo,
}

/// Side information required for autopilot client tools.
///
/// This should contain all IDs that might be needed as input to a tool
/// that do not need to be generated by LLMs (like the session id or a config hash).
/// We should implement this as a type that has optional or mandatory fields as needed
/// for each kind of tool, then implement TryFrom<AutopilotSideInfo> for each tool's side info type.
/// This can fail if the correct information is not present.
#[derive(Debug, Clone, Serialize, Deserialize, ts_rs::TS)]
pub struct AutopilotSideInfo {
    /// The event ID of the ToolCall event (for correlating ToolResult).
    pub tool_call_event_id: Uuid,

    /// The session ID for this autopilot session.
    pub session_id: Uuid,

    /// A hash of the current configuration.
    pub config_snapshot_hash: String,

    /// Settings for optimization workflows run on the gateway by autopilot.
    pub optimization: OptimizationWorkflowSideInfo,
}

/// Side info for optimization workflow tool (hidden from LLM).
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema, ts_rs::TS)]
pub struct OptimizationWorkflowSideInfo {
    /// Polling interval in seconds (default: 60).
    #[serde(default = "default_poll_interval_secs")]
    pub poll_interval_secs: u64,

    /// Maximum time to wait for completion in seconds (default: 86400 = 24 hours).
    #[serde(default = "default_max_wait_secs")]
    pub max_wait_secs: u64,
}

impl Default for OptimizationWorkflowSideInfo {
    fn default() -> Self {
        Self {
            poll_interval_secs: default_poll_interval_secs(),
            max_wait_secs: default_max_wait_secs(),
        }
    }
}
fn default_poll_interval_secs() -> u64 {
    60
}

fn default_max_wait_secs() -> u64 {
    86400
}

impl From<AutopilotSideInfo> for OptimizationWorkflowSideInfo {
    fn from(params: AutopilotSideInfo) -> Self {
        // This tool doesn't use the standard autopilot params - it has its own config.
        // Return defaults for polling configuration.
        params.optimization
    }
}

impl AutopilotSideInfo {
    /// Helper for tools that create new datapoints to get bookkeeping info.
    pub fn to_tags(&self) -> HashMap<String, String> {
        let mut tags = HashMap::new();
        tags.insert(
            "tensorzero::autopilot::tool_call_event_id".to_string(),
            self.tool_call_event_id.to_string(),
        );
        tags.insert(
            "tensorzero::autopilot::session_id".to_string(),
            self.session_id.to_string(),
        );
        tags.insert(
            "tensorzero::autopilot::config_snapshot_hash".to_string(),
            self.config_snapshot_hash.clone(),
        );
        tags
    }
}

/// Implemented so that tools that don't need side info are able to satisfy trait bounds.
impl From<AutopilotSideInfo> for () {
    fn from(_: AutopilotSideInfo) -> Self {}
}

#[derive(Debug, Clone, Serialize, Deserialize, ts_rs::TS)]
pub struct AutopilotToolResult {
    pub result: String,
}

#[derive(Clone, Debug, Deserialize, Serialize, ts_rs::TS)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ToolCallDecisionSource {
    Ui,
}

#[derive(Debug, Clone, Serialize, Deserialize, ts_rs::TS)]
pub struct ToolCallAuthorization {
    pub source: ToolCallDecisionSource,
    pub tool_call_event_id: Uuid,
    pub status: ToolCallAuthorizationStatus,
}

#[derive(Clone, Debug, Deserialize, Serialize, ts_rs::TS)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ToolCallAuthorizationStatus {
    Approved,
    Rejected { reason: String },
}

#[derive(Clone, Debug, Deserialize, Serialize, ts_rs::TS)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ToolOutcome {
    Success(AutopilotToolResult),
    Failure {
        /// Structured error data from the tool.
        /// For autopilot tools, this is typically a serialized `AutopilotToolError`
        /// with a `kind` field discriminator (e.g., "ClientError", "Validation").
        error: serde_json::Value,
    },
    Missing,
    #[serde(other)]
    Other,
}

// =============================================================================
// Request Types
// =============================================================================

/// Request body for creating an event.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateEventRequest {
    pub deployment_id: String,
    pub tensorzero_version: String,
    pub payload: EventPayload,
    /// Used for idempotency when adding events to an existing session.
    ///
    /// When provided (for non-nil `session_id`), the server validates that this ID matches
    /// the most recent `user_message` event in the session. This prevents duplicate events
    /// from being created if a client retries a create user request that already succeeded.
    /// This should only apply to Message events.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub previous_user_message_event_id: Option<Uuid>,
    /// Must be set if the session id is nil and we are starting a new session
    pub config_snapshot_hash: Option<String>,
}

/// Query parameters for listing events.
#[derive(Debug, Clone, Default, Serialize, Deserialize, ts_rs::TS)]
#[ts(export)]
pub struct ListEventsParams {
    /// Maximum number of events to return. Defaults to 20.
    #[ts(optional)]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub limit: Option<u32>,
    /// Cursor for pagination: return events with id < before.
    #[ts(optional)]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub before: Option<Uuid>,
}

/// Query parameters for listing sessions.
#[derive(Debug, Clone, Default, Serialize, Deserialize, ts_rs::TS)]
#[ts(export)]
pub struct ListSessionsParams {
    /// Maximum number of sessions to return. Defaults to 20.
    #[ts(optional)]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub limit: Option<u32>,
    /// Offset for pagination.
    #[ts(optional)]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub offset: Option<u32>,
}

/// Query parameters for streaming events.
#[derive(Debug, Clone, Default, Serialize, Deserialize, ts_rs::TS)]
#[ts(export)]
pub struct StreamEventsParams {
    /// Resume streaming from this event ID (exclusive).
    #[ts(optional)]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_event_id: Option<Uuid>,
}

// =============================================================================
// Response Types
// =============================================================================

/// Response from creating an event.
#[derive(Debug, Clone, Serialize, Deserialize, ts_rs::TS)]
#[ts(export)]
pub struct CreateEventResponse {
    pub event_id: Uuid,
    pub session_id: Uuid,
}

/// Response from listing events.
#[derive(Debug, Clone, Serialize, Deserialize, ts_rs::TS)]
#[ts(export)]
pub struct ListEventsResponse {
    pub events: Vec<Event>,
    /// The most recent `message` event with role `user` in this session.
    pub previous_user_message_event_id: Uuid,
    /// The current status of the Autopilot in this session.
    /// Ignores pagination parameters.
    pub status: AutopilotStatus,
    /// All tool calls in Event history that do not have responses.
    /// These may be duplicates of some of the values in events.
    /// All EventPayloads in these Events should be of type ToolCall.
    #[serde(default)]
    pub pending_tool_calls: Vec<Event>,
}

/// Response from listing sessions.
#[derive(Debug, Clone, Serialize, Deserialize, ts_rs::TS)]
#[ts(export)]
pub struct ListSessionsResponse {
    pub sessions: Vec<Session>,
}

// =============================================================================
// Error Types
// =============================================================================

/// Error response from the API.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ErrorResponse {
    pub error: ErrorDetail,
}

/// Details of an error.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ErrorDetail {
    pub message: String,
}
