use durable::{ControlFlow, DurableError, TaskError};
use serde::Serialize;
use serde_json::Value as JsonValue;
use tensorzero_derive::TensorZeroDeserialize;
use thiserror::Error;

/// Error type for tool execution.
///
/// This enum separates control flow signals and non-serializable errors
/// from serializable errors that can be persisted and returned in API responses.
#[derive(Debug, Error)]
pub enum ToolError {
    /// Durable control flow signal (suspend, cancelled).
    /// This is internal and should never be serialized.
    #[error("Control flow: {0:?}")]
    Control(ControlFlow),

    /// Database operation failed.
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),

    /// JSON serialization/deserialization error.
    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),

    /// A serializable tool error.
    #[error(transparent)]
    NonControl(#[from] NonControlToolError),
}

/// Serializable error type for tool execution.
///
/// This enum contains framework-level errors generated by durable-tools itself,
/// plus a `User` variant for tool-specific errors. Tool implementations should
/// define their own error types and convert them to `NonControlToolError::User`.
#[derive(Debug, Error, Serialize, TensorZeroDeserialize)]
#[serde(tag = "kind")]
#[serde(rename_all = "snake_case")]
pub enum NonControlToolError {
    /// Tool was not found in the registry.
    #[error("Tool not found: {name}")]
    ToolNotFound { name: String },

    /// Tool with this name is already registered.
    #[error("Tool '{name}' is already registered. Each tool name must be unique.")]
    DuplicateToolName { name: String },

    /// Parameter validation or parsing failed.
    #[error("Parameter error: {message}")]
    InvalidParams { message: String },

    /// Schema generation failed.
    #[error("Schema generation failed: {message}")]
    SchemaGeneration { message: String },

    /// Operation timed out.
    #[error("Timed out waiting for '{step_name}'")]
    Timeout { step_name: String },

    /// Validation error.
    #[error("Validation error: {message}")]
    Validation { message: String },

    /// Internal task error.
    #[error("Internal error: {message}")]
    Internal { message: String },

    /// Child task failed.
    #[error("Child task failed at '{step_name}': {message}")]
    ChildFailed { step_name: String, message: String },

    /// Child task was cancelled.
    #[error("Child task was cancelled at '{step_name}'")]
    ChildCancelled { step_name: String },

    /// Invalid durable configuration.
    #[error("Invalid configuration: {reason}")]
    InvalidConfiguration { reason: String },

    /// Reserved header prefix used.
    #[error("Header key '{key}' uses reserved prefix 'durable::'")]
    ReservedHeaderPrefix { key: String },

    /// Invalid event name.
    #[error("Invalid event name: {reason}")]
    InvalidEventName { reason: String },

    /// User-defined error from tool implementation.
    ///
    /// Tool implementations should define their own error types and convert
    /// them to this variant. The `error_data` field stores structured JSON
    /// that can be deserialized back to the original error type.
    #[error("{message}")]
    User {
        /// Human-readable error message.
        message: String,
        /// Structured error data for persistence and later retrieval.
        error_data: JsonValue,
    },

    //// Error occurred while trying to spawn a subtask
    #[error("failed to spawn subtask `{name}`: {error}")]
    SubtaskSpawnFailed { name: String, error: String },

    /// Error occurred while trying to emit an event.
    #[error("failed to emit event `{event_name}`: {error}")]
    EmitEventFailed { event_name: String, error: String },
}

/// Result type alias for tool operations.
pub type ToolResult<T> = Result<T, ToolError>;

/// Extension trait for ergonomic control error propagation.
pub trait ToolResultExt<T> {
    /// Propagates control, database, and serialization errors.
    /// Returns inner result for non-control cases that can be handled.
    ///
    /// # Usage
    ///
    /// ```ignore
    /// let inner_result = some_tool_call().await.propagate_control()?;
    /// match inner_result {
    ///     Ok(value) => { /* use value */ },
    ///     Err(non_control_err) => { /* handle error */ },
    /// }
    /// ```
    fn propagate_control(self) -> Result<Result<T, NonControlToolError>, ToolError>;
}

impl<T> ToolResultExt<T> for ToolResult<T> {
    fn propagate_control(self) -> Result<Result<T, NonControlToolError>, ToolError> {
        match self {
            Ok(v) => Ok(Ok(v)),
            Err(ToolError::Control(cf)) => Err(ToolError::Control(cf)),
            Err(ToolError::Database(e)) => Err(ToolError::Database(e)),
            Err(ToolError::Serialization(e)) => Err(ToolError::Serialization(e)),
            Err(ToolError::NonControl(e)) => Ok(Err(e)),
        }
    }
}

impl From<TaskError> for ToolError {
    fn from(err: TaskError) -> Self {
        match err {
            TaskError::Control(cf) => ToolError::Control(cf),
            TaskError::Database(e) => ToolError::Database(e),
            TaskError::Serialization(e) => ToolError::Serialization(e),
            TaskError::Timeout { step_name } => {
                ToolError::NonControl(NonControlToolError::Timeout { step_name })
            }
            TaskError::User {
                message,
                error_data,
            } => ToolError::NonControl(NonControlToolError::User {
                message,
                error_data,
            }),
            TaskError::Validation { message } => {
                ToolError::NonControl(NonControlToolError::Validation { message })
            }
            TaskError::TaskInternal(e) => ToolError::NonControl(NonControlToolError::Internal {
                message: e.to_string(),
            }),
            TaskError::ChildFailed { step_name, message } => {
                ToolError::NonControl(NonControlToolError::ChildFailed { step_name, message })
            }
            TaskError::ChildCancelled { step_name } => {
                ToolError::NonControl(NonControlToolError::ChildCancelled { step_name })
            }
            TaskError::SubtaskSpawnFailed { name, error } => {
                ToolError::NonControl(NonControlToolError::SubtaskSpawnFailed {
                    name,
                    error: error.to_string(),
                })
            }
            TaskError::EmitEventFailed { event_name, error } => {
                ToolError::NonControl(NonControlToolError::EmitEventFailed {
                    event_name,
                    error: error.to_string(),
                })
            }
        }
    }
}

impl From<ToolError> for TaskError {
    fn from(err: ToolError) -> Self {
        match err {
            ToolError::Control(cf) => TaskError::Control(cf),
            ToolError::Database(e) => TaskError::Database(e),
            ToolError::Serialization(e) => TaskError::Serialization(e),
            ToolError::NonControl(e) => e.into(),
        }
    }
}

impl From<NonControlToolError> for TaskError {
    fn from(err: NonControlToolError) -> Self {
        match err {
            NonControlToolError::Timeout { step_name } => TaskError::Timeout { step_name },
            NonControlToolError::User {
                message,
                error_data,
            } => TaskError::User {
                message,
                error_data,
            },
            NonControlToolError::Validation { message } => TaskError::Validation { message },
            NonControlToolError::Internal { message } => {
                TaskError::TaskInternal(anyhow::anyhow!("{message}"))
            }
            NonControlToolError::ChildFailed { step_name, message } => {
                TaskError::ChildFailed { step_name, message }
            }
            NonControlToolError::ChildCancelled { step_name } => {
                TaskError::ChildCancelled { step_name }
            }
            // For all other variants, use the Serialize impl to generate error_data
            other => {
                let error_data = serde_json::to_value(&other).unwrap_or_else(|e| {
                    serde_json::json!({
                        "kind": "error_serialization_failed",
                        "serialization_error": e.to_string(),
                    })
                });
                let message = other.to_string();
                TaskError::User {
                    message,
                    error_data,
                }
            }
        }
    }
}

impl From<DurableError> for ToolError {
    fn from(err: DurableError) -> Self {
        match err {
            DurableError::Database(e) => ToolError::Database(e),
            DurableError::Serialization(e) => ToolError::Serialization(e),
            DurableError::TaskNotRegistered { task_name } => {
                ToolError::NonControl(NonControlToolError::ToolNotFound { name: task_name })
            }
            DurableError::TaskAlreadyRegistered { task_name } => {
                ToolError::NonControl(NonControlToolError::DuplicateToolName { name: task_name })
            }
            DurableError::InvalidConfiguration { reason } => {
                ToolError::NonControl(NonControlToolError::InvalidConfiguration { reason })
            }
            DurableError::ReservedHeaderPrefix { key } => {
                ToolError::NonControl(NonControlToolError::ReservedHeaderPrefix { key })
            }
            DurableError::InvalidEventName { reason } => {
                ToolError::NonControl(NonControlToolError::InvalidEventName { reason })
            }
            DurableError::InvalidTaskParams { message, .. } => {
                ToolError::NonControl(NonControlToolError::InvalidParams { message })
            }
        }
    }
}
