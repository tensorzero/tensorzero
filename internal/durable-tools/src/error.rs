use durable::{ControlFlow, DurableError, TaskError};
use serde_json::Value as JsonValue;
use thiserror::Error;

/// Error type for tool execution.
///
/// This enum contains framework-level errors generated by durable-tools itself,
/// plus a `User` variant for tool-specific errors. Tool implementations should
/// define their own error types and convert them to `ToolError::User`.
#[derive(Debug, Error)]
pub enum ToolError {
    /// Tool was not found in the registry.
    #[error("Tool not found: {0}")]
    ToolNotFound(String),

    /// Tool with this name is already registered.
    #[error("Tool '{0}' is already registered. Each tool name must be unique.")]
    DuplicateToolName(String),

    /// Parameter validation or parsing failed.
    #[error("Parameter error: {0}")]
    InvalidParams(String),

    /// Schema generation failed.
    #[error("Schema generation failed: {0}")]
    SchemaGeneration(anyhow::Error),

    /// JSON serialization/deserialization error.
    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),

    /// Database operation failed.
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),

    /// Durable control flow signal (suspend, cancelled).
    #[error("Control flow: {0:?}")]
    Control(ControlFlow),

    /// Operation timed out.
    #[error("Timed out waiting for '{step_name}'")]
    Timeout {
        /// The name of the step or event that timed out.
        step_name: String,
    },

    /// User-defined error from tool implementation.
    ///
    /// Tool implementations should define their own error types and convert
    /// them to this variant. The `error_data` field stores structured JSON
    /// that can be deserialized back to the original error type.
    #[error("{message}")]
    User {
        /// Human-readable error message.
        message: String,
        /// Structured error data for persistence and later retrieval.
        error_data: JsonValue,
    },
}

/// Result type alias for tool operations.
pub type ToolResult<T> = Result<T, ToolError>;

impl From<TaskError> for ToolError {
    fn from(err: TaskError) -> Self {
        match err {
            TaskError::Control(cf) => ToolError::Control(cf),
            TaskError::Database(e) => ToolError::Database(e),
            TaskError::Serialization(e) => ToolError::Serialization(e),
            TaskError::Timeout { step_name } => ToolError::Timeout { step_name },
            TaskError::User {
                message,
                error_data,
            } => ToolError::User {
                message,
                error_data,
            },
            TaskError::Validation { message } => ToolError::User {
                message: message.clone(),
                error_data: serde_json::json!({
                    "kind": "Validation",
                    "message": message,
                }),
            },
            TaskError::TaskInternal(e) => {
                let message = e.to_string();
                ToolError::User {
                    message: message.clone(),
                    error_data: serde_json::json!({
                        "kind": "Internal",
                        "message": message,
                    }),
                }
            }
            TaskError::ChildFailed { step_name, message } => ToolError::User {
                message: format!("child task failed at '{step_name}': {message}"),
                error_data: serde_json::json!({
                    "kind": "ChildFailed",
                    "step_name": step_name,
                    "message": message,
                }),
            },
            TaskError::ChildCancelled { step_name } => ToolError::User {
                message: format!("child task was cancelled at '{step_name}'"),
                error_data: serde_json::json!({
                    "kind": "ChildCancelled",
                    "step_name": step_name,
                }),
            },
        }
    }
}

impl From<ToolError> for TaskError {
    fn from(err: ToolError) -> Self {
        match err {
            ToolError::Control(cf) => TaskError::Control(cf),
            ToolError::Database(e) => TaskError::Database(e),
            ToolError::Serialization(e) => TaskError::Serialization(e),
            ToolError::Timeout { step_name } => TaskError::Timeout { step_name },
            ToolError::User {
                message,
                error_data,
            } => TaskError::User {
                message,
                error_data,
            },
            ToolError::ToolNotFound(name) => TaskError::User {
                message: format!("Tool not found: {name}"),
                error_data: serde_json::json!({
                    "kind": "ToolNotFound",
                    "name": name,
                }),
            },
            ToolError::DuplicateToolName(name) => TaskError::User {
                message: format!("Tool '{name}' is already registered"),
                error_data: serde_json::json!({
                    "kind": "DuplicateToolName",
                    "name": name,
                }),
            },
            ToolError::InvalidParams(msg) => TaskError::User {
                message: format!("Parameter error: {msg}"),
                error_data: serde_json::json!({
                    "kind": "InvalidParams",
                    "message": msg,
                }),
            },
            ToolError::SchemaGeneration(e) => TaskError::User {
                message: format!("Schema generation failed: {e}"),
                error_data: serde_json::json!({
                    "kind": "SchemaGeneration",
                    "message": e.to_string(),
                }),
            },
        }
    }
}

impl From<DurableError> for ToolError {
    fn from(err: DurableError) -> Self {
        match err {
            DurableError::Database(e) => ToolError::Database(e),
            DurableError::Serialization(e) => ToolError::Serialization(e),
            DurableError::TaskNotRegistered { task_name } => ToolError::ToolNotFound(task_name),
            DurableError::TaskAlreadyRegistered { task_name } => {
                ToolError::DuplicateToolName(task_name)
            }
            DurableError::InvalidConfiguration { reason } => ToolError::User {
                message: format!("Durable configuration invalid: {reason}"),
                error_data: serde_json::json!({
                    "kind": "InvalidConfiguration",
                    "reason": reason,
                }),
            },
            DurableError::ReservedHeaderPrefix { key } => ToolError::User {
                message: format!(
                    "header key '{key}' uses reserved prefix 'durable::'. \
                     User headers cannot start with 'durable::'."
                ),
                error_data: serde_json::json!({
                    "kind": "ReservedHeaderPrefix",
                    "key": key,
                }),
            },
            DurableError::InvalidEventName { reason } => ToolError::User {
                message: format!("invalid event name: {reason}"),
                error_data: serde_json::json!({
                    "kind": "InvalidEventName",
                    "reason": reason,
                }),
            },
        }
    }
}
