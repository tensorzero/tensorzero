// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.
import type { ProviderTool } from "./ProviderTool";
import type { Tool } from "./Tool";
import type { ToolChoice } from "./ToolChoice";

/**
 * Wire/API representation of dynamic tool parameters for inference requests.
 *
 * This type is the **wire format** for tool configurations used in API requests and responses.
 * It distinguishes between static tools (configured in the function) and dynamic tools
 * (provided at runtime), allowing clients to reference pre-configured tools by name or
 * provide new tools on-the-fly.
 *
 * # Purpose
 * - Accept tool parameters in inference API requests (e.g., `/inference/{function_name}`)
 * - Expose tool configurations in API responses for stored inferences
 * - Support Python and TypeScript client bindings
 * - Allow runtime customization of tool behavior
 *
 * # Fields
 * - `allowed_tools`: Names of static tools from function config to use (subset selection)
 * - `additional_tools`: New tools defined at runtime (not in static config)
 * - `tool_choice`: Override the function's default tool choice strategy
 * - `parallel_tool_calls`: Override whether parallel tool calls are enabled
 * - `provider_tools`: Provider-specific tool configurations (not persisted to database)
 *
 * # Key Differences from ToolCallConfigDatabaseInsert
 * - **Separate lists**: Maintains distinction between static (`allowed_tools`) and dynamic (`additional_tools`) tools
 * - **By reference**: Static tools referenced by name, not duplicated
 * - **Has provider_tools**: Can specify provider-specific tool configurations
 * - **Has bindings**: Exposed to Python/TypeScript via `pyo3` and `ts_rs`
 *
 * # Conversion to Storage Format
 * Converting from `DynamicToolParams` to `ToolCallConfigDatabaseInsert` is a **lossy** operation:
 * 1. Static tools (from `allowed_tools` names) are resolved from function config
 * 2. Dynamic tools (from `additional_tools`) are included as-is
 * 3. Both lists are merged into a single `tools_available` list
 * 4. The distinction between static and dynamic tools is lost
 * 5. `provider_tools` are dropped (not stored)
 *
 * Use `FunctionConfig::dynamic_tool_params_to_database_insert()` for this conversion.
 *
 * # Conversion from Storage Format
 * Converting from `ToolCallConfigDatabaseInsert` back to `DynamicToolParams` reconstructs the original:
 * 1. `dynamic_tools` → `additional_tools`
 * 2. `allowed_tools` → `allowed_tools` (based on choice enum)
 * 3. Other fields copied directly
 *
 * Use `From<ToolCallConfigDatabaseInsert> for DynamicToolParams` for this conversion.
 *
 * # Example
 * ```rust,ignore
 * // API request with dynamic tool params
 * let params = DynamicToolParams {
 *     allowed_tools: Some(vec!["calculator".to_string()]),  // Use only the calculator tool from config
 *     additional_tools: Some(vec![Tool {  runtime tool  }]),  // Add a new tool
 *     tool_choice: Some(ToolChoice::Required),
 *     parallel_tool_calls: Some(true),
 *     provider_tools: vec![],
 * };
 *
 * // Convert to storage format
 * let db_insert = function_config
 *     .dynamic_tool_params_to_database_insert(params, &static_tools)?
 *     .unwrap_or_default();
 *
 * // db_insert.tools_available now contains both the calculator tool (from config)
 * // and the runtime tool (from additional_tools), merged together
 * ```
 *
 * See also: [`ToolCallConfigDatabaseInsert`] for the storage/database format
 */
export type DynamicToolParams = {
  /**
   * A subset of static tools configured for the function that the inference is allowed to use. Optional.
   * If not provided, all static tools are allowed.
   */
  allowed_tools?: Array<string>;
  /**
   * Tools that the user provided at inference time (not in function config), in addition to the function-configured
   * tools, that are also allowed.
   */
  additional_tools?: Array<Tool>;
  /**
   * User-specified tool choice strategy. If provided during inference, it will override the function-configured tool choice.
   * Optional.
   */
  tool_choice?: ToolChoice;
  /**
   * Whether to use parallel tool calls in the inference. Optional.
   * If provided during inference, it will override the function-configured parallel tool calls.
   */
  parallel_tool_calls?: boolean;
  /**
   * Provider-specific tool configurations
   */
  provider_tools: Array<ProviderTool>;
};
