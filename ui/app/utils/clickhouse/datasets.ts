import { z } from "zod";
import {
  contentBlockChatOutputSchema,
  jsonInferenceOutputSchema,
  displayInputSchema,
  JsonValueSchema,
} from "./common";

/**
 * Schema representing a fully-qualified row in the Chat Inference dataset.
 */
export const ChatInferenceDatapointRowSchema = z
  .object({
    dataset_name: z.string(),
    function_name: z.string(),
    name: z.string().nullable(),
    id: z.string().uuid(),
    episode_id: z.string().uuid().nullable(),
    input: z.string(),
    output: z.string().nullable(),
    tool_params: z.string(),
    tags: z.record(z.string(), z.string()),
    auxiliary: z.string(),
    is_deleted: z.boolean().default(false),
    updated_at: z.string().datetime().default(new Date().toISOString()),
    staled_at: z.string().datetime().nullable(),
    source_inference_id: z.string().uuid().nullable(),
    is_custom: z.boolean(),
  })
  .strict();
export type ChatInferenceDatapointRow = z.infer<
  typeof ChatInferenceDatapointRowSchema
>;

/**
 * Schema representing a fully-qualified row in the JSON Inference dataset.
 */
export const JsonInferenceDatapointRowSchema = z
  .object({
    dataset_name: z.string(),
    function_name: z.string(),
    name: z.string().nullable(),
    id: z.string().uuid(),
    episode_id: z.string().uuid().nullable(),
    input: z.string(),
    output: z.string().nullable(),
    output_schema: z.string(),
    tags: z.record(z.string(), z.string()),
    auxiliary: z.string(),
    is_deleted: z.boolean().default(false),
    updated_at: z.string().datetime(),
    staled_at: z.string().datetime().nullable(),
    source_inference_id: z.string().uuid().nullable(),
    is_custom: z.boolean(),
  })
  .strict();
export type JsonInferenceDatapointRow = z.infer<
  typeof JsonInferenceDatapointRowSchema
>;

/**
 * Union schema representing a dataset row, which can be either a Chat or JSON inference row.
 */
export const DatapointRowSchema = z.union([
  ChatInferenceDatapointRowSchema,
  JsonInferenceDatapointRowSchema,
]);
export type DatapointRow = z.infer<typeof DatapointRowSchema>;

export const ParsedChatInferenceDatapointRowSchema =
  ChatInferenceDatapointRowSchema.omit({
    input: true,
    output: true,
    tool_params: true,
  }).extend({
    input: displayInputSchema,
    output: z.array(contentBlockChatOutputSchema).optional(),
    tool_params: z.record(z.string(), JsonValueSchema).optional(),
    is_custom: z.boolean(),
    tags: z.record(z.string(), z.string()),
  });
export type ParsedChatInferenceDatapointRow = z.infer<
  typeof ParsedChatInferenceDatapointRowSchema
>;

export const ParsedJsonInferenceDatapointRowSchema =
  JsonInferenceDatapointRowSchema.omit({
    input: true,
    output: true,
    output_schema: true,
  }).extend({
    input: displayInputSchema,
    output: jsonInferenceOutputSchema.optional(),
    output_schema: JsonValueSchema,
    is_custom: z.boolean(),
  });
export type ParsedJsonInferenceDatapointRow = z.infer<
  typeof ParsedJsonInferenceDatapointRowSchema
>;

/**
 * Union schema representing a parsed dataset row, which can be either a Chat or JSON inference row.
 */
export const ParsedDatasetRowSchema = z.union([
  ParsedChatInferenceDatapointRowSchema,
  ParsedJsonInferenceDatapointRowSchema,
]);
export type ParsedDatasetRow = z.infer<typeof ParsedDatasetRowSchema>;

/**
 * Schema for inserts into the Chat Inference dataset.
 * Note: "is_deleted" and "created_at" are omitted since they are generated by the database.
 */
export const ChatInferenceDatapointInsertSchema =
  ChatInferenceDatapointRowSchema.omit({
    is_deleted: true,
    updated_at: true,
  });
export type ChatInferenceDatapointInsert = z.infer<
  typeof ChatInferenceDatapointInsertSchema
>;

/**
 * Schema for inserts into the JSON Inference dataset.
 * Note: "is_deleted" and "created_at" are omitted since they are generated by the database.
 */
export const JsonInferenceDatapointInsertSchema =
  JsonInferenceDatapointRowSchema.omit({
    is_deleted: true,
    updated_at: true,
  });
export type JsonInferenceDatapointInsert = z.infer<
  typeof JsonInferenceDatapointInsertSchema
>;

/**
 * Union schema representing an insert into either dataset.
 */
export const DatapointInsertSchema = z.union([
  ChatInferenceDatapointInsertSchema,
  JsonInferenceDatapointInsertSchema,
]);
export type DatapointInsert = z.infer<typeof DatapointInsertSchema>;

/**
 * Schema defining the allowed query parameters for selecting rows from the ChatInference or JsonInference tables
 * to be added to a dataset.
 */
export const DatasetQueryParamsSchema = z.object({
  inferenceType: z.enum(["chat", "json"]),
  function_name: z.string().optional(),
  dataset_name: z.string().optional(),
  variant_name: z.string().optional(), // variant_name must have a corresponding function_name
  extra_where: z.string().array().default([]), // Extra WHERE clauses (e.g. filtering by episode_id)
  extra_params: z
    .record(z.string(), z.union([z.string(), z.number()]))
    .default({}), // Additional query parameters for placeholder substitution
  metric_filter: z
    .object({
      metric: z.string(),
      metric_type: z.enum(["boolean", "float"]),
      operator: z.enum([">", "<"]),
      threshold: z.number(),
      join_on: z.enum(["id", "episode_id"]),
    })
    .optional(), // Optional filter based on metric feedback
  output_source: z.enum(["none", "inference", "demonstration"]),
  limit: z.number().optional(),
  offset: z.number().optional(),
  is_custom: z.boolean().optional(),
});
export type DatasetQueryParams = z.infer<typeof DatasetQueryParamsSchema>;

export const DatasetCountInfoSchema = z.object({
  dataset_name: z.string(),
  count: z.number(),
  last_updated: z.string().datetime(),
});
export type DatasetCountInfo = z.infer<typeof DatasetCountInfoSchema>;

export const DatasetDetailRowSchema = z.object({
  id: z.string().uuid(),
  type: z.enum(["chat", "json"]),
  function_name: z.string(),
  name: z.string().nullable(),
  episode_id: z.string().uuid().nullable(),
  updated_at: z.string().datetime(),
});

export type DatasetDetailRow = z.infer<typeof DatasetDetailRowSchema>;
