# /// script
# dependencies = [
#   "requests",
# ]
# ///

import concurrent.futures
import hashlib
import os
import subprocess
import time
from pathlib import Path

import requests

# cd to directory of this file
os.chdir(os.path.dirname(os.path.abspath(__file__)))

# Constants
PART_SIZE = 8388608

# List of fixture files (local filenames)
# These are uploaded with path-based versioning: {version}/{filename}
FIXTURE_FILES = [
    "boolean_metric_feedback_examples.jsonl",
    "chat_inference_datapoint_examples.jsonl",
    "chat_inference_examples.jsonl",
    "comment_feedback_examples.jsonl",
    "demonstration_feedback_examples.jsonl",
    "dynamic_evaluation_run_episode_examples.jsonl",
    "dynamic_evaluation_run_examples.jsonl",
    "float_metric_feedback_examples.jsonl",
    "jaro_winkler_similarity_feedback.jsonl",
    "json_inference_datapoint_examples.jsonl",
    "json_inference_examples.jsonl",
    "model_inference_examples.jsonl",
]

# Model inference cache is versioned separately (regenerated by CI)
MODEL_INFERENCE_CACHE_FILE = "model_inference_cache_e2e.jsonl"

R2_BUCKET = "https://pub-147e9850a60643208c411e70b636e956.r2.dev"
# Download directly to the fixtures directory (not a subdirectory)
FIXTURES_DIR = Path(".")


def calculate_etag(file_path):
    """Calculate S3/R2 style ETag for a file."""
    file_size = os.path.getsize(file_path)
    num_parts = (file_size + PART_SIZE - 1) // PART_SIZE

    if num_parts == 1:
        # Single part upload - just MD5 of the file
        with open(file_path, "rb") as f:
            return hashlib.md5(f.read()).hexdigest()
    else:
        # Multipart upload - concatenate MD5s of each part
        md5s = []
        with open(file_path, "rb") as f:
            while True:
                chunk = f.read(PART_SIZE)
                if not chunk:
                    break
                md5s.append(hashlib.md5(chunk).digest())

        # Calculate MD5 of concatenated part MD5s
        combined_md5 = hashlib.md5(b"".join(md5s)).hexdigest()
        return f"{combined_md5}-{num_parts}"


def get_remote_etag(remote_filename):
    """Get ETag from R2 bucket."""
    response = requests.head(f"{R2_BUCKET}/{remote_filename}")
    return response.headers.get("ETag", "").strip('"')


def download_file(remote_filename, local_filename, remote_etag):
    """Download file from R2 bucket."""
    RETRIES = 3
    for i in range(RETRIES):
        try:
            url = f"{R2_BUCKET}/{remote_filename}"
            response = requests.get(url, stream=True)
            response.raise_for_status()

            local_file = FIXTURES_DIR / local_filename

            with open(local_file, "wb") as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)

            local_etag = calculate_etag(local_file)
            if local_etag != remote_etag:
                raise Exception(f"ETag mismatch after downloading: {local_etag} != {remote_etag}")
            return
        except Exception as e:
            print(
                f"Error downloading `{remote_filename}` (attempt {i + 1} of {RETRIES}): {e}",
                flush=True,
            )
            time.sleep(1)
    raise Exception(f"Failed to download `{remote_filename}` after {RETRIES} attempts")


def build_fixtures_dict():
    """Build fixtures dict from version files."""
    fixtures_version = Path("fixtures-version.txt").read_text().strip()
    cache_version = Path("model-inference-cache-version.txt").read_text().strip()

    # Build mapping: remote path -> local filename
    fixtures = {}
    for filename in FIXTURE_FILES:
        fixtures[f"{fixtures_version}/{filename}"] = filename
    fixtures[f"{cache_version}/{MODEL_INFERENCE_CACHE_FILE}"] = MODEL_INFERENCE_CACHE_FILE

    return fixtures


def main():
    fixtures = build_fixtures_dict()

    if os.environ.get("R2_ACCESS_KEY_ID") is not None and os.environ.get("R2_SECRET_ACCESS_KEY"):
        print("R2_ACCESS_KEY_ID set, downloading fixtures using 'aws s3 cp'", flush=True)
        for remote_filename, local_filename in fixtures.items():
            local_file = FIXTURES_DIR / local_filename
            subprocess.check_call(
                f"aws s3 --region auto --endpoint-url https://19918a216783f0ac9e052233569aef60.r2.cloudflarestorage.com/ "
                f"cp s3://tensorzero-fixtures/{remote_filename} {local_file}",
                env={
                    "AWS_ACCESS_KEY_ID": os.environ["R2_ACCESS_KEY_ID"],
                    "AWS_SECRET_ACCESS_KEY": os.environ["R2_SECRET_ACCESS_KEY"],
                    "PATH": os.environ.get("PATH", ""),
                },
                shell=True,
            )
        return

    def process_fixture(item):
        remote_filename, local_filename = item
        local_file = FIXTURES_DIR / local_filename
        remote_etag = get_remote_etag(remote_filename)

        if not local_file.exists():
            print(
                f"Downloading {remote_filename} (file doesn't exist locally)",
                flush=True,
            )
            download_file(remote_filename, local_filename, remote_etag)
            return

        local_etag = calculate_etag(local_file)

        if local_etag != remote_etag:
            print(f"Downloading {remote_filename} (ETag mismatch)", flush=True)
            print(f"Local ETag: {local_etag}", flush=True)
            print(f"Remote ETag: {remote_etag}", flush=True)
            download_file(remote_filename, local_filename, remote_etag)
        else:
            print(f"Skipping {remote_filename} (up to date)", flush=True)

    # Use ThreadPoolExecutor to download files in parallel
    with concurrent.futures.ThreadPoolExecutor() as executor:
        # Loop over the results to propagate exceptions
        for result in executor.map(process_fixture, fixtures.items()):
            assert result is None


if __name__ == "__main__":
    main()
