# generated by datamodel-codegen:
#   filename:  datasets_v1.json
#   timestamp: 2025-11-06T01:44:18+00:00

from __future__ import annotations

from enum import Enum
from typing import Any
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field, RootModel


class Arguments(RootModel[dict[str, Any]]):
    root: dict[str, Any]


class Base64File(BaseModel):
    data: str
    detail: str | None = None
    mime_type: str
    source_url: str | None = None


class Type(Enum):
    text = "text"


class Type1(Enum):
    tool_call = "tool_call"


class Type2(Enum):
    thought = "thought"


class Type3(Enum):
    unknown = "unknown"


class ContentBlockChatOutput4(BaseModel):
    data: Any
    model_provider_name: str | None = None
    type: Type3


class Type4(Enum):
    chat = "chat"


class Type5(Enum):
    json = "json"


class CreateDatapointsFromInferenceOutputSource(Enum):
    none = "none"
    inference = "inference"
    demonstration = "demonstration"


class CreateDatapointsResponse(BaseModel):
    ids: list[UUID] = Field(
        ..., description="The IDs of the newly-generated datapoints."
    )


class DatapointMetadataUpdate(BaseModel):
    name: str | None = Field(
        None,
        description="Datapoint name. If omitted, it will be left unchanged. If specified as `null`, it will be set to `null`. If specified as a value, it will be set to the provided value.",
    )


class DeleteDatapointsRequest(BaseModel):
    ids: list[UUID] = Field(..., description="The IDs of the datapoints to delete.")


class DeleteDatapointsResponse(BaseModel):
    num_deleted_datapoints: int = Field(
        ..., description="The number of deleted datapoints.", ge=0
    )


class FileType(Enum):
    url = "url"


class FileType1(Enum):
    base64 = "base64"


class File2(Base64File):
    file_type: FileType1


class FileType2(Enum):
    object_storage_pointer = "object_storage_pointer"


class FileType3(Enum):
    object_storage = "object_storage"


class FileType4(Enum):
    object_storage_error = "object_storage_error"


class GetDatapointsRequest(BaseModel):
    ids: list[UUID] = Field(
        ..., description="The IDs of the datapoints to retrieve. Required."
    )


class InferenceResponseToolCall(BaseModel):
    arguments: Any | None = Field(
        None,
        description="The arguments of the tool to call, validated against tool configs. If not present, it means the tool call arguments were invalid.",
    )
    id: str = Field(
        ...,
        description="A Tool Call ID to match up with tool call responses. See #4058.",
    )
    name: str | None = Field(
        None,
        description="The name of the tool to call, validated against tool configs. If not present, it means the tool call was invalid.",
    )
    raw_arguments: str = Field(
        ...,
        description="The raw arguments JSON string of the tool to call, as generated by the model.",
    )
    raw_name: str = Field(
        ..., description="The name of the tool to call, as generated by the model."
    )


class Type6(Enum):
    text = "text"


class Type7(Enum):
    template = "template"


class Type8(Enum):
    tool_call = "tool_call"


class Type9(Enum):
    tool_result = "tool_result"


class Type10(Enum):
    raw_text = "raw_text"


class Type11(Enum):
    thought = "thought"


class Type12(Enum):
    file = "file"


class Type13(Enum):
    unknown = "unknown"


class JsonDatapointOutputUpdate(BaseModel):
    raw: str = Field(
        ...,
        description="The raw output of the datapoint. For valid JSON outputs, this should be a JSON-serialized string.",
    )


class ObjectStoragePointer(BaseModel):
    detail: str | None = None
    mime_type: str
    source_url: str | None = None
    storage_path: dict[str, Any]


class ProviderToolScope1(BaseModel):
    model_name: str
    model_provider_name: str


class ProviderToolScope(RootModel[ProviderToolScope1 | None]):
    root: ProviderToolScope1 | None


class RawText(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    value: str


class Role(Enum):
    user = "user"
    assistant = "assistant"


class System(RootModel[str | Arguments]):
    root: str | Arguments


class Template(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    arguments: Arguments
    name: str


class Text(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    text: str


class Type14(Enum):
    summary_text = "summary_text"


class ThoughtSummaryBlock1(BaseModel):
    text: str
    type: Type14


class ThoughtSummaryBlock(RootModel[ThoughtSummaryBlock1]):
    root: ThoughtSummaryBlock1


class Tool(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    description: str
    name: str
    parameters: Any
    strict: bool | None = None


class ToolCall(BaseModel):
    arguments: str
    id: str
    name: str


class ToolCallWrapper(RootModel[ToolCall | InferenceResponseToolCall]):
    root: ToolCall | InferenceResponseToolCall = Field(
        ...,
        description="`ToolCallWrapper` helps us disambiguate between `ToolCall` (no `raw_*`) and `InferenceResponseToolCall` (has `raw_*`).",
    )


class ToolChoice1(Enum):
    none = "none"


class ToolChoice2(Enum):
    auto = "auto"


class ToolChoice3(Enum):
    required = "required"


class ToolChoice4(BaseModel):
    specific: str


class ToolChoice(RootModel[ToolChoice1 | ToolChoice2 | ToolChoice3 | ToolChoice4]):
    root: ToolChoice1 | ToolChoice2 | ToolChoice3 | ToolChoice4 = Field(
        ...,
        description="Most inference providers allow the user to force a tool to be used\nand even specify which tool to be used.\n\nThis enum is used to denote this tool choice.",
    )


class ToolResult(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: str
    name: str
    result: str


class Unknown(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    data: Any = Field(
        ...,
        description="The underlying content block to be passed to the model provider.",
    )
    model_provider_name: str | None = Field(
        None,
        description="A fully-qualified name specifying when this content block should\nbe included in the model provider input.",
    )


class UpdateDatapointMetadataRequest(BaseModel):
    id: UUID = Field(..., description="The ID of the datapoint to update. Required.")
    metadata: DatapointMetadataUpdate = Field(
        ..., description="Metadata fields to update."
    )


class Type15(Enum):
    chat = "chat"


class Type16(Enum):
    json = "json"


class UpdateDatapointsMetadataRequest(BaseModel):
    datapoints: list[UpdateDatapointMetadataRequest] = Field(
        ..., description="The datapoints to update metadata for."
    )


class UpdateDatapointsResponse(BaseModel):
    ids: list[UUID] = Field(
        ...,
        description="The IDs of the datapoints that were updated.\nThese are newly generated IDs for UpdateDatapoint requests, and they are the same IDs for UpdateDatapointMetadata requests.",
    )


class UrlFile(BaseModel):
    detail: str | None = None
    mime_type: str | None = None
    url: str


class ContentBlockChatOutput1(Text):
    type: Type


class ContentBlockChatOutput2(InferenceResponseToolCall):
    type: Type1


class File1(UrlFile):
    file_type: FileType


class File3(ObjectStoragePointer):
    file_type: FileType2


class InputMessageContent1(Text):
    type: Type6


class InputMessageContent2(Template):
    type: Type7


class InputMessageContent3(BaseModel):
    type: Type8


class InputMessageContent4(ToolResult):
    type: Type9


class InputMessageContent5(RawText):
    type: Type10


class InputMessageContent8(Unknown):
    type: Type13


class ObjectStorageError(ObjectStoragePointer):
    error: str | None = None


class ObjectStorageFile(ObjectStoragePointer):
    data: str


class ProviderTool(BaseModel):
    scope: ProviderToolScope | None = None
    tool: Any


class Thought(BaseModel):
    field_internal_provider_type: str | None = Field(
        None,
        alias="_internal_provider_type",
        description="When set, this 'Thought' block will only be used for providers\nmatching this type (e.g. `anthropic`). Other providers will emit\na warning and discard the block.",
    )
    signature: str | None = Field(
        None,
        description="An optional signature - currently, this is only used with Anthropic,\nand is ignored by other providers.",
    )
    summary: list[ThoughtSummaryBlock] | None = None
    text: str | None = None


class ContentBlockChatOutput3(Thought):
    type: Type2


class ContentBlockChatOutput(
    RootModel[
        ContentBlockChatOutput1
        | ContentBlockChatOutput2
        | ContentBlockChatOutput3
        | ContentBlockChatOutput4
    ]
):
    root: (
        ContentBlockChatOutput1
        | ContentBlockChatOutput2
        | ContentBlockChatOutput3
        | ContentBlockChatOutput4
    ) = Field(
        ...,
        description="Defines the types of content block that can come from a `chat` function",
    )


class DynamicToolParams(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    additional_tools: list[Tool] | None = Field(
        None,
        description="Tools that the user provided at inference time (not in function config), in addition to the function-configured\ntools, that are also allowed.",
    )
    allowed_tools: list[str] | None = Field(
        None,
        description="A subset of static tools configured for the function that the inference is allowed to use. Optional.\nIf not provided, all static tools are allowed.",
    )
    parallel_tool_calls: bool | None = Field(
        None,
        description="Whether to use parallel tool calls in the inference. Optional.\nIf provided during inference, it will override the function-configured parallel tool calls.",
    )
    provider_tools: list[ProviderTool] | None = Field(
        None,
        description="Provider-specific tool configurations (not persisted to database)",
    )
    tool_choice: ToolChoice | None = None


class File4(ObjectStorageFile):
    file_type: FileType3


class File5(ObjectStorageError):
    file_type: FileType4


class File(RootModel[File1 | File2 | File3 | File4 | File5]):
    root: File1 | File2 | File3 | File4 | File5 = Field(
        ..., description="A file for an inference or a datapoint."
    )


class InputMessageContent6(Thought):
    type: Type11


class InputMessageContent7(BaseModel):
    type: Type12


class InputMessageContent(
    RootModel[
        InputMessageContent1
        | InputMessageContent2
        | InputMessageContent3
        | InputMessageContent4
        | InputMessageContent5
        | InputMessageContent6
        | InputMessageContent7
        | InputMessageContent8
    ]
):
    root: (
        InputMessageContent1
        | InputMessageContent2
        | InputMessageContent3
        | InputMessageContent4
        | InputMessageContent5
        | InputMessageContent6
        | InputMessageContent7
        | InputMessageContent8
    )


class InputMessage(BaseModel):
    content: list[InputMessageContent]
    role: Role


class Input(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    messages: list[InputMessage] | None = None
    system: System | None = None


class UpdateChatDatapointRequest(BaseModel):
    id: UUID = Field(..., description="The ID of the datapoint to update. Required.")
    input: Input | None = None
    metadata: DatapointMetadataUpdate | None = None
    output: list[ContentBlockChatOutput] | None = Field(
        None,
        description="Chat datapoint output. If omitted, it will be left unchanged. If empty, it will be cleared. Otherwise,\nit will overwrite the existing output.",
    )
    tags: dict[str, Any] | None = Field(
        None,
        description="Datapoint tags. If omitted, it will be left unchanged. If empty, it will be cleared. Otherwise,\nit will be overwrite the existing tags.",
    )
    tool_params: DynamicToolParams | None = None


class UpdateDatapointRequest1(UpdateChatDatapointRequest):
    type: Type15


class UpdateJsonDatapointRequest(BaseModel):
    id: UUID = Field(..., description="The ID of the datapoint to update. Required.")
    input: Input | None = None
    metadata: DatapointMetadataUpdate | None = None
    output: JsonDatapointOutputUpdate | None = None
    output_schema: Any | None = Field(
        None,
        description="The output schema of the JSON datapoint. If omitted, it will be left unchanged. If specified as `null`, it will be set to `null`. If specified as a value, it will be set to the provided value.\nIf not provided, the function's output schema will be used.",
    )
    tags: dict[str, Any] | None = Field(
        None,
        description="Datapoint tags. If omitted, it will be left unchanged. If empty, it will be cleared. Otherwise,\nit will be overwrite the existing tags.",
    )


class CreateChatDatapointRequest(DynamicToolParams):
    episode_id: UUID | None = Field(
        None, description="Episode ID that the datapoint belongs to. Optional."
    )
    function_name: str = Field(
        ..., description="The function name for this datapoint. Required."
    )
    input: Input = Field(..., description="Input to the function. Required.")
    name: str | None = Field(
        None, description="Human-readable name for the datapoint. Optional."
    )
    output: list[ContentBlockChatOutput] | None = Field(
        None, description="Chat datapoint output. Optional."
    )
    tags: dict[str, Any] | None = Field(
        None, description="Tags associated with this datapoint. Optional."
    )


class CreateDatapointRequest1(CreateChatDatapointRequest):
    type: Type4


class CreateJsonDatapointRequest(BaseModel):
    episode_id: UUID | None = Field(
        None, description="Episode ID that the datapoint belongs to. Optional."
    )
    function_name: str = Field(
        ..., description="The function name for this datapoint. Required."
    )
    input: Input = Field(..., description="Input to the function. Required.")
    name: str | None = Field(
        None, description="Human-readable name for the datapoint. Optional."
    )
    output: JsonDatapointOutputUpdate | None = None
    output_schema: Any | None = Field(
        None,
        description="The output schema of the JSON datapoint. Optional.\nIf not provided, the function's output schema will be used. If provided, it will be validated.",
    )
    tags: dict[str, Any] | None = Field(
        None, description="Tags associated with this datapoint. Optional."
    )


class UpdateDatapointRequest2(UpdateJsonDatapointRequest):
    type: Type16


class UpdateDatapointRequest(
    RootModel[UpdateDatapointRequest1 | UpdateDatapointRequest2]
):
    root: UpdateDatapointRequest1 | UpdateDatapointRequest2 = Field(
        ..., description="A tagged request to update a single datapoint in a dataset."
    )


class UpdateDatapointsRequest(BaseModel):
    datapoints: list[UpdateDatapointRequest] = Field(
        ..., description="The datapoints to update."
    )


class CreateDatapointRequest2(CreateJsonDatapointRequest):
    type: Type5


class CreateDatapointRequest(
    RootModel[CreateDatapointRequest1 | CreateDatapointRequest2]
):
    root: CreateDatapointRequest1 | CreateDatapointRequest2 = Field(
        ..., description="A tagged request to create a single datapoint."
    )


class CreateDatapointsRequest(BaseModel):
    datapoints: list[CreateDatapointRequest] = Field(
        ..., description="The datapoints to create."
    )
