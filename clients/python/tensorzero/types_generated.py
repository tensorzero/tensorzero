# generated by datamodel-codegen:
#   filename:  datasets_v1.json
#   timestamp: 2025-11-06T01:48:47+00:00

from __future__ import annotations

from enum import Enum
from typing import Annotated, Any, Literal
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field, RootModel


class Base64File(BaseModel):
    """
    A file already encoded as base64
    """

    data: str
    detail: str | None = None
    mime_type: str
    source_url: str | None = None


class ContentBlockChatOutput4(BaseModel):
    """
    Defines the types of content block that can come from a `chat` function
    """

    data: Any
    model_provider_name: str | None = None
    type: Literal["unknown"]


class CreateDatapointsFromInferenceOutputSource(Enum):
    """
    Specifies the source of the output for the datapoint when creating datapoints from inferences.
    - `None`: Do not include any output in the datapoint.
    - `Inference`: Include the original inference output in the datapoint.
    - `Demonstration`: Include the latest demonstration feedback as output in the datapoint.
    """

    none = "none"
    inference = "inference"
    demonstration = "demonstration"


class CreateDatapointsResponse(BaseModel):
    """
    Response from creating datapoints.
    """

    ids: Annotated[
        list[UUID], Field(description="The IDs of the newly-generated datapoints.")
    ]


class DatapointMetadataUpdate(BaseModel):
    """
    A request to update the metadata of a datapoint.
    """

    name: Annotated[
        str | None,
        Field(
            description="Datapoint name. If omitted, it will be left unchanged. If specified as `null`, it will be set to `null`. If specified as a value, it will be set to the provided value."
        ),
    ] = None


class DeleteDatapointsRequest(BaseModel):
    """
    Request to delete datapoints from a dataset.
    """

    ids: Annotated[
        list[UUID], Field(description="The IDs of the datapoints to delete.")
    ]


class DeleteDatapointsResponse(BaseModel):
    """
    Response containing the number of deleted datapoints.
    """

    num_deleted_datapoints: Annotated[
        int, Field(description="The number of deleted datapoints.", ge=0)
    ]


class File2(Base64File):
    """
    A file for an inference or a datapoint.
    """

    file_type: Literal["base64"]


class GetDatapointsRequest(BaseModel):
    """
    Request to get specific datapoints by their IDs.
    Used by the `POST /v1/datasets/get_datapoints` endpoint.
    """

    ids: Annotated[
        list[UUID],
        Field(description="The IDs of the datapoints to retrieve. Required."),
    ]


class InferenceResponseToolCall(BaseModel):
    """
    An InferenceResponseToolCall is a request by a model to call a Tool
    in the form that we return to the client / ClickHouse
    """

    arguments: Annotated[
        Any | None,
        Field(
            description="The arguments of the tool to call, validated against tool configs. If not present, it means the tool call arguments were invalid."
        ),
    ] = None
    id: Annotated[
        str,
        Field(
            description="A Tool Call ID to match up with tool call responses. See #4058."
        ),
    ]
    name: Annotated[
        str | None,
        Field(
            description="The name of the tool to call, validated against tool configs. If not present, it means the tool call was invalid."
        ),
    ] = None
    raw_arguments: Annotated[
        str,
        Field(
            description="The raw arguments JSON string of the tool to call, as generated by the model."
        ),
    ]
    raw_name: Annotated[
        str,
        Field(description="The name of the tool to call, as generated by the model."),
    ]


class JsonDatapointOutputUpdate(BaseModel):
    """
    A request to update the output of a JSON datapoint.
    We intentionally only accept the `raw` field (in a JSON-serialized string), because datapoints can contain invalid outputs, and it's desirable
    for users to run evals against them.
    """

    raw: Annotated[
        str,
        Field(
            description="The raw output of the datapoint. For valid JSON outputs, this should be a JSON-serialized string."
        ),
    ]


class ObjectStoragePointer(BaseModel):
    """
    A file stored in an object storage backend, without data.
    This struct can be stored in the database. It's used by `StoredFile` (`StoredInput`).
    Note: `File` supports both `ObjectStorageFilePointer` and `ObjectStorageFile`.
    """

    detail: str | None = None
    mime_type: str
    source_url: str | None = None
    storage_path: dict[str, Any]


class ProviderToolScope1(BaseModel):
    model_name: str
    model_provider_name: str


class RawText(BaseModel):
    """
    Struct that represents raw text content that should be passed directly to the model
    without any template processing or validation
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    value: str


class Role(Enum):
    user = "user"
    assistant = "assistant"


class Template(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    arguments: dict[str, Any]
    name: str


class Text(BaseModel):
    """
    InputMessages are validated against the input schema of the Function
    and then templated and transformed into RequestMessages for a particular Variant.
    They might contain tool calls or tool results along with text.
    The abstraction we use to represent this is ContentBlock, which is a union of Text, ToolCall, and ToolResult.
    ContentBlocks are collected into RequestMessages.
    These RequestMessages are collected into a ModelInferenceRequest,
    which should contain all information needed by a ModelProvider to perform the
    inference that is called for.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    text: str


class ThoughtSummaryBlock1(BaseModel):
    text: str
    type: Literal["summary_text"]


class ThoughtSummaryBlock(RootModel[ThoughtSummaryBlock1]):
    root: ThoughtSummaryBlock1


class Tool(BaseModel):
    """
    A Tool object describes how a tool can be dynamically configured by the user.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    description: str
    name: str
    parameters: Any
    strict: bool | None = None


class ToolCall(BaseModel):
    arguments: str
    id: str
    name: str


class ToolCallWrapper(RootModel[ToolCall | InferenceResponseToolCall]):
    root: Annotated[
        ToolCall | InferenceResponseToolCall,
        Field(
            description="`ToolCallWrapper` helps us disambiguate between `ToolCall` (no `raw_*`) and `InferenceResponseToolCall` (has `raw_*`)."
        ),
    ]


class ToolChoice1(BaseModel):
    """
    Most inference providers allow the user to force a tool to be used
    and even specify which tool to be used.

    This enum is used to denote this tool choice.
    """

    specific: str


class ToolResult(BaseModel):
    """
    A ToolResult is the outcome of a ToolCall, which we may want to present back to the model
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    id: str
    name: str
    result: str


class Unknown(BaseModel):
    """
    Struct that represents an unknown provider-specific content block.
    We pass this along as-is without any validation or transformation.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    data: Annotated[
        Any,
        Field(
            description="The underlying content block to be passed to the model provider."
        ),
    ]
    model_provider_name: Annotated[
        str | None,
        Field(
            description="A fully-qualified name specifying when this content block should\nbe included in the model provider input."
        ),
    ] = None


class UpdateDatapointMetadataRequest(BaseModel):
    """
    A request to update the metadata of a single datapoint.
    """

    id: Annotated[
        UUID, Field(description="The ID of the datapoint to update. Required.")
    ]
    metadata: Annotated[
        DatapointMetadataUpdate, Field(description="Metadata fields to update.")
    ]


class UpdateDatapointsMetadataRequest(BaseModel):
    """
    Request to update metadata for one or more datapoints in a dataset.
    Used by the `PATCH /v1/datasets/{dataset_id}/datapoints/metadata` endpoint.
    """

    datapoints: Annotated[
        list[UpdateDatapointMetadataRequest],
        Field(description="The datapoints to update metadata for."),
    ]


class UpdateDatapointsResponse(BaseModel):
    """
    A response to a request to update one or more datapoints in a dataset.
    """

    ids: Annotated[
        list[UUID],
        Field(
            description="The IDs of the datapoints that were updated.\nThese are newly generated IDs for UpdateDatapoint requests, and they are the same IDs for UpdateDatapointMetadata requests."
        ),
    ]


class UrlFile(BaseModel):
    """
    A file that can be located at a URL
    """

    detail: str | None = None
    mime_type: str | None = None
    url: str


class ContentBlockChatOutput1(Text):
    """
    Defines the types of content block that can come from a `chat` function
    """

    type: Literal["text"]


class ContentBlockChatOutput2(InferenceResponseToolCall):
    """
    Defines the types of content block that can come from a `chat` function
    """

    type: Literal["tool_call"]


class File1(UrlFile):
    """
    A file for an inference or a datapoint.
    """

    file_type: Literal["url"]


class File3(ObjectStoragePointer):
    """
    A file for an inference or a datapoint.
    """

    file_type: Literal["object_storage_pointer"]


class InputMessageContent1(Text):
    type: Literal["text"]


class InputMessageContent2(Template):
    type: Literal["template"]


class InputMessageContent3(BaseModel):
    type: Literal["tool_call"]


class InputMessageContent4(ToolResult):
    type: Literal["tool_result"]


class InputMessageContent5(RawText):
    type: Literal["raw_text"]


class InputMessageContent8(Unknown):
    """
    An unknown content block type, used to allow passing provider-specific
    content blocks (e.g. Anthropic's `redacted_thinking`) in and out
    of TensorZero.
    The `data` field holds the original content block from the provider,
    without any validation or transformation by TensorZero.
    """

    type: Literal["unknown"]


class ObjectStorageError(ObjectStoragePointer):
    """
    A file that we failed to read from object storage.
    This struct can NOT be stored in the database.
    """

    error: str | None = None


class ObjectStorageFile(ObjectStoragePointer):
    """
    A file stored in an object storage backend, with data.
    This struct can NOT be stored in the database.
    Note: `File` supports both `ObjectStorageFilePointer` and `ObjectStorageFile`.
    """

    data: str


class ProviderTool(BaseModel):
    scope: ProviderToolScope1 | None = None
    tool: Any


class Thought(BaseModel):
    """
    Struct that represents a model's reasoning
    """

    field_internal_provider_type: Annotated[
        str | None,
        Field(
            alias="_internal_provider_type",
            description="When set, this 'Thought' block will only be used for providers\nmatching this type (e.g. `anthropic`). Other providers will emit\na warning and discard the block.",
        ),
    ] = None
    signature: Annotated[
        str | None,
        Field(
            description="An optional signature - currently, this is only used with Anthropic,\nand is ignored by other providers."
        ),
    ] = None
    summary: list[ThoughtSummaryBlock] | None = None
    text: str | None = None


class ContentBlockChatOutput3(Thought):
    """
    Defines the types of content block that can come from a `chat` function
    """

    type: Literal["thought"]


class DynamicToolParams(BaseModel):
    """
    Wire/API representation of dynamic tool parameters for inference requests.

    This type is the **wire format** for tool configurations used in API requests and responses.
    It distinguishes between static tools (configured in the function) and dynamic tools
    (provided at runtime), allowing clients to reference pre-configured tools by name or
    provide new tools on-the-fly.

    # Purpose
    - Accept tool parameters in inference API requests (e.g., `/inference/{function_name}`)
    - Expose tool configurations in API responses for stored inferences
    - Support Python and TypeScript client bindings
    - Allow runtime customization of tool behavior

    # Fields
    - `allowed_tools`: Names of static tools from function config to use (subset selection)
    - `additional_tools`: New tools defined at runtime (not in static config)
    - `tool_choice`: Override the function's default tool choice strategy
    - `parallel_tool_calls`: Override whether parallel tool calls are enabled
    - `provider_tools`: Provider-specific tool configurations (not persisted to database)

    # Key Differences from ToolCallConfigDatabaseInsert
    - **Separate lists**: Maintains distinction between static (`allowed_tools`) and dynamic (`additional_tools`) tools
    - **By reference**: Static tools referenced by name, not duplicated
    - **Has provider_tools**: Can specify provider-specific tool configurations
    - **Has bindings**: Exposed to Python/TypeScript via `pyo3` and `ts_rs`

    # Conversion to Storage Format
    Converting from `DynamicToolParams` to `ToolCallConfigDatabaseInsert` is a **lossy** operation:
    1. Static tools (from `allowed_tools` names) are resolved from function config
    2. Dynamic tools (from `additional_tools`) are included as-is
    3. Both lists are merged into a single `tools_available` list
    4. The distinction between static and dynamic tools is lost
    5. `provider_tools` are dropped (not stored)

    Use `FunctionConfig::dynamic_tool_params_to_database_insert()` for this conversion.

    # Conversion from Storage Format
    Converting from `ToolCallConfigDatabaseInsert` back to `DynamicToolParams` attempts to reconstruct the original:
    1. Tools that match function config tool names → `allowed_tools`
    2. Tools that don't match function config → `additional_tools`
    3. `provider_tools` is set to `None` (cannot be recovered)

    Use `FunctionConfig::database_insert_to_dynamic_tool_params()` for this conversion.

    # Example
    ```rust,ignore
    // API request with dynamic tool params
    let params = DynamicToolParams {
        allowed_tools: Some(vec!["calculator".to_string()]),  // Use only the calculator tool from config
        additional_tools: Some(vec![Tool {  runtime tool  }]),  // Add a new tool
        tool_choice: Some(ToolChoice::Required),
        parallel_tool_calls: Some(true),
        provider_tools: None,
    };

    // Convert to storage format (merge tools, lose distinction)
    let db_insert = function_config
        .dynamic_tool_params_to_database_insert(params, &static_tools)?
        .unwrap_or_default();

    // db_insert.tools_available now contains both the calculator tool (from config)
    // and the runtime tool (from additional_tools), merged together
    ```

    See also: [`ToolCallConfigDatabaseInsert`] for the storage/database format
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    additional_tools: Annotated[
        list[Tool] | None,
        Field(
            description="Tools that the user provided at inference time (not in function config), in addition to the function-configured\ntools, that are also allowed."
        ),
    ] = None
    allowed_tools: Annotated[
        list[str] | None,
        Field(
            description="A subset of static tools configured for the function that the inference is allowed to use. Optional.\nIf not provided, all static tools are allowed."
        ),
    ] = None
    parallel_tool_calls: Annotated[
        bool | None,
        Field(
            description="Whether to use parallel tool calls in the inference. Optional.\nIf provided during inference, it will override the function-configured parallel tool calls."
        ),
    ] = None
    provider_tools: Annotated[
        list[ProviderTool] | None,
        Field(
            description="Provider-specific tool configurations (not persisted to database)"
        ),
    ] = None
    tool_choice: (
        Literal["none"] | Literal["auto"] | Literal["required"] | ToolChoice1 | None
    ) = None


class File4(ObjectStorageFile):
    """
    A file for an inference or a datapoint.
    """

    file_type: Literal["object_storage"]


class File5(ObjectStorageError):
    """
    A file for an inference or a datapoint.
    """

    file_type: Literal["object_storage_error"]


class File(RootModel[File1 | File2 | File3 | File4 | File5]):
    root: Annotated[
        File1 | File2 | File3 | File4 | File5,
        Field(description="A file for an inference or a datapoint."),
    ]


class InputMessageContent6(Thought):
    type: Literal["thought"]


class InputMessageContent7(BaseModel):
    type: Literal["file"]


class InputMessage(BaseModel):
    """
    InputMessage and Role are our representation of the input sent by the client
    prior to any processing into LLM representations below.
    `InputMessage` has a custom deserializer that addresses legacy data formats that we used to support (see input_message.rs).
    """

    content: list[
        InputMessageContent1
        | InputMessageContent2
        | InputMessageContent3
        | InputMessageContent4
        | InputMessageContent5
        | InputMessageContent6
        | InputMessageContent7
        | InputMessageContent8
    ]
    role: Role


class Input(BaseModel):
    """
    A request is made that contains an Input
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    messages: list[InputMessage] | None = None
    system: str | dict[str, Any] | None = None


class UpdateChatDatapointRequest(BaseModel):
    """
    An update request for a chat datapoint.
    For any fields that are optional in ChatInferenceDatapoint, the request field distinguishes between an omitted field, `null`, and a value:
    - If the field is omitted, it will be left unchanged.
    - If the field is specified as `null`, it will be set to `null`.
    - If the field has a value, it will be set to the provided value.

    In Rust this is modeled as an `Option<Option<T>>`, where `None` means "unchanged" and `Some(None)` means "set to `null`" and `Some(Some(T))` means "set to the provided value".
    """

    id: Annotated[
        UUID, Field(description="The ID of the datapoint to update. Required.")
    ]
    input: Input | None = None
    metadata: DatapointMetadataUpdate | None = None
    output: Annotated[
        list[
            ContentBlockChatOutput1
            | ContentBlockChatOutput2
            | ContentBlockChatOutput3
            | ContentBlockChatOutput4
        ]
        | None,
        Field(
            description="Chat datapoint output. If omitted, it will be left unchanged. If empty, it will be cleared. Otherwise,\nit will overwrite the existing output."
        ),
    ] = None
    tags: Annotated[
        dict[str, Any] | None,
        Field(
            description="Datapoint tags. If omitted, it will be left unchanged. If empty, it will be cleared. Otherwise,\nit will be overwrite the existing tags."
        ),
    ] = None
    tool_params: DynamicToolParams | None = None


class UpdateDatapointRequest1(UpdateChatDatapointRequest):
    """
    Request to update a chat datapoint.
    """

    type: Literal["chat"]


class UpdateJsonDatapointRequest(BaseModel):
    """
    An update request for a JSON datapoint.
    For any fields that are optional in JsonInferenceDatapoint, the request field distinguishes between an omitted field, `null`, and a value:
    - If the field is omitted, it will be left unchanged.
    - If the field is specified as `null`, it will be set to `null`.
    - If the field has a value, it will be set to the provided value.

    In Rust this is modeled as an `Option<Option<T>>`, where `None` means "unchanged" and `Some(None)` means "set to `null`" and `Some(Some(T))` means "set to the provided value".
    """

    id: Annotated[
        UUID, Field(description="The ID of the datapoint to update. Required.")
    ]
    input: Input | None = None
    metadata: DatapointMetadataUpdate | None = None
    output: JsonDatapointOutputUpdate | None = None
    output_schema: Annotated[
        Any | None,
        Field(
            description="The output schema of the JSON datapoint. If omitted, it will be left unchanged. If specified as `null`, it will be set to `null`. If specified as a value, it will be set to the provided value.\nIf not provided, the function's output schema will be used."
        ),
    ] = None
    tags: Annotated[
        dict[str, Any] | None,
        Field(
            description="Datapoint tags. If omitted, it will be left unchanged. If empty, it will be cleared. Otherwise,\nit will be overwrite the existing tags."
        ),
    ] = None


class CreateChatDatapointRequest(DynamicToolParams):
    """
    A request to create a chat datapoint.
    """

    episode_id: Annotated[
        UUID | None,
        Field(description="Episode ID that the datapoint belongs to. Optional."),
    ] = None
    function_name: Annotated[
        str, Field(description="The function name for this datapoint. Required.")
    ]
    input: Annotated[Input, Field(description="Input to the function. Required.")]
    name: Annotated[
        str | None,
        Field(description="Human-readable name for the datapoint. Optional."),
    ] = None
    output: Annotated[
        list[
            ContentBlockChatOutput1
            | ContentBlockChatOutput2
            | ContentBlockChatOutput3
            | ContentBlockChatOutput4
        ]
        | None,
        Field(description="Chat datapoint output. Optional."),
    ] = None
    tags: Annotated[
        dict[str, Any] | None,
        Field(description="Tags associated with this datapoint. Optional."),
    ] = None


class CreateDatapointRequest1(CreateChatDatapointRequest):
    """
    Request to create a chat datapoint.
    """

    type: Literal["chat"]


class CreateJsonDatapointRequest(BaseModel):
    """
    A request to create a JSON datapoint.
    """

    episode_id: Annotated[
        UUID | None,
        Field(description="Episode ID that the datapoint belongs to. Optional."),
    ] = None
    function_name: Annotated[
        str, Field(description="The function name for this datapoint. Required.")
    ]
    input: Annotated[Input, Field(description="Input to the function. Required.")]
    name: Annotated[
        str | None,
        Field(description="Human-readable name for the datapoint. Optional."),
    ] = None
    output: JsonDatapointOutputUpdate | None = None
    output_schema: Annotated[
        Any | None,
        Field(
            description="The output schema of the JSON datapoint. Optional.\nIf not provided, the function's output schema will be used. If provided, it will be validated."
        ),
    ] = None
    tags: Annotated[
        dict[str, Any] | None,
        Field(description="Tags associated with this datapoint. Optional."),
    ] = None


class UpdateDatapointRequest2(UpdateJsonDatapointRequest):
    """
    Request to update a JSON datapoint.
    """

    type: Literal["json"]


class UpdateDatapointsRequest(BaseModel):
    """
    Request to update one or more datapoints in a dataset.
    """

    datapoints: Annotated[
        list[UpdateDatapointRequest1 | UpdateDatapointRequest2],
        Field(description="The datapoints to update."),
    ]


class CreateDatapointRequest2(CreateJsonDatapointRequest):
    """
    Request to create a JSON datapoint.
    """

    type: Literal["json"]


class CreateDatapointsRequest(BaseModel):
    """
    Request to create datapoints manually.
    Used by the `POST /v1/datasets/{dataset_id}/datapoints` endpoint.
    """

    datapoints: Annotated[
        list[CreateDatapointRequest1 | CreateDatapointRequest2],
        Field(description="The datapoints to create."),
    ]
