"""
Auto-generated Python dataclasses from JSON schemas.

This file is generated from JSON schemas in the tensorzero-core crate.
Do not edit this file manually - it will be overwritten.

Generated from schemas in: tensorzero-core/schemas/

To regenerate, run:
    python generate_schema_types.py
"""

class _UnsetType:
    """Sentinel value to distinguish between omitted fields and null values."""

    def __repr__(self):
        return "UNSET"


UNSET = _UnsetType()
"""
Sentinel value to distinguish between omitted and null in API requests.

Usage:
- UNSET: Field is omitted (don't change existing value)
- None: Field is explicitly set to null
- value: Field is set to the provided value

Example:
    # Omit the field entirely (don't update it)
    update = UpdateRequest(name=UNSET)

    # Set the field to null (clear the existing value)
    update = UpdateRequest(name=None)

    # Set the field to a value
    update = UpdateRequest(name="new_value")
"""



from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Literal

Model = Any


class Detail(Enum):
    """
    Detail level for input images (affects fidelity and token cost)
    """

    low = 'low'
    high = 'high'
    auto = 'auto'


@dataclass(kw_only=True)
class ToolCall:
    id: str
    name: str
    arguments: str


@dataclass(kw_only=True)
class FileUrl:
    url: str
    mime_type: str | None = None
    detail: Detail | None = None


@dataclass(kw_only=True)
class ObjectStorageFile:
    """
    A file stored in an object storage backend, with data.
    This struct can NOT be stored in the database.
    Note: `File` supports both `ObjectStorageFilePointer` and `ObjectStorageFile`.
    """

    mime_type: str
    storage_path: str
    data: str
    source_url: str | None = None
    detail: Detail | None = None


@dataclass(kw_only=True)
class Base64FileMetadata:
    """
    Like `Base64File`, but without the data field.
    """

    mime_type: str
    source_url: str | None = None
    detail: Detail | None = None


@dataclass(kw_only=True)
class ThoughtSummaryBlock1:
    text: str
    type: Literal['summary_text'] = 'summary_text'


ThoughtSummaryBlock = ThoughtSummaryBlock1


@dataclass(kw_only=True)
class Thought:
    """
    Struct that represents a model's reasoning
    """

    text: str | None = None
    signature: str | None = None
    """
    An optional signature - currently, this is only used with Anthropic,
    and is ignored by other providers.
    """
    summary: list[ThoughtSummaryBlock] | None = None
    field_internal_provider_type: str | None = None
    """
    When set, this 'Thought' block will only be used for providers
    matching this type (e.g. `anthropic`). Other providers will emit
    a warning and discard the block.
    """


@dataclass(kw_only=True)
class InferenceResponseToolCall:
    """
    An InferenceResponseToolCall is a request by a model to call a Tool
    in the form that we return to the client / ClickHouse
    """

    id: str
    """
    A Tool Call ID to match up with tool call responses. See #4058.
    """
    raw_name: str
    """
    The name of the tool to call, as generated by the model.
    """
    raw_arguments: str
    """
    The raw arguments JSON string of the tool to call, as generated by the model.
    """
    name: str | None = None
    """
    The name of the tool to call, validated against tool configs. If not present, it means the tool call was invalid.
    """
    arguments: Any | None = None
    """
    The arguments of the tool to call, validated against tool configs. If not present, it means the tool call arguments were invalid.
    """


@dataclass(kw_only=True)
class Tool:
    """
    A Tool object describes how a tool can be dynamically configured by the user.
    """

    description: str
    parameters: Any
    name: str
    strict: bool | None = False


class ToolChoice1(Enum):
    """
    Most inference providers allow the user to force a tool to be used
    and even specify which tool to be used.

    This enum is used to denote this tool choice.
    """

    none = 'none'
    auto = 'auto'
    required = 'required'


@dataclass(kw_only=True)
class ToolChoice2:
    """
    Most inference providers allow the user to force a tool to be used
    and even specify which tool to be used.

    This enum is used to denote this tool choice.
    """

    specific: str


ToolChoice = ToolChoice1 | ToolChoice2


@dataclass(kw_only=True)
class ProviderToolScope1:
    model_name: str
    model_provider_name: str


ProviderToolScope = ProviderToolScope1 | None


@dataclass(kw_only=True)
class UrlFile:
    """
    A file that can be located at a URL
    """

    url: str
    mime_type: str | None = None
    detail: Detail | None = None


@dataclass(kw_only=True)
class Base64File:
    """
    A file already encoded as base64
    """

    mime_type: str
    data: str
    source_url: str | None = None
    detail: Detail | None = None


@dataclass(kw_only=True)
class ObjectStoragePointer:
    """
    A file stored in an object storage backend, without data.
    This struct can be stored in the database. It's used by `StoredFile` (`StoredInput`).
    Note: `File` supports both `ObjectStorageFilePointer` and `ObjectStorageFile`.
    """

    mime_type: str
    storage_path: str
    source_url: str | None = None
    detail: Detail | None = None


@dataclass(kw_only=True)
class ObjectStorageError:
    """
    A file that we failed to read from object storage.
    This struct can NOT be stored in the database.
    """

    mime_type: str
    storage_path: str
    source_url: str | None = None
    detail: Detail | None = None
    error: str | None = None


@dataclass(kw_only=True)
class Arguments:
    """
    A newtype wrapper around Map<String, Value> for template and system arguments
    """


class Role(Enum):
    user = 'user'
    assistant = 'assistant'


@dataclass(kw_only=True)
class InputMessageContent1:
    """
    InputMessages are validated against the input schema of the Function
    and then templated and transformed into RequestMessages for a particular Variant.
    They might contain tool calls or tool results along with text.
    The abstraction we use to represent this is ContentBlock, which is a union of Text, ToolCall, and ToolResult.
    ContentBlocks are collected into RequestMessages.
    These RequestMessages are collected into a ModelInferenceRequest,
    which should contain all information needed by a ModelProvider to perform the
    inference that is called for.
    """

    text: str
    type: Literal['text'] = 'text'


@dataclass(kw_only=True)
class InputMessageContent2:
    name: str
    arguments: Arguments
    type: Literal['template'] = 'template'


@dataclass(kw_only=True)
class InputMessageContent3(ToolCall):
    """
    `ToolCallWrapper` helps us disambiguate between `ToolCall` (no `raw_*`) and `InferenceResponseToolCall` (has `raw_*`).
    """

    type: Literal['tool_call'] = 'tool_call'


@dataclass(kw_only=True)
class InputMessageContent4(InferenceResponseToolCall):
    """
    `ToolCallWrapper` helps us disambiguate between `ToolCall` (no `raw_*`) and `InferenceResponseToolCall` (has `raw_*`).
    """

    type: Literal['tool_call'] = 'tool_call'


@dataclass(kw_only=True)
class InputMessageContent5:
    """
    A ToolResult is the outcome of a ToolCall, which we may want to present back to the model
    """

    name: str
    result: str
    id: str
    type: Literal['tool_result'] = 'tool_result'


@dataclass(kw_only=True)
class InputMessageContent6:
    """
    Struct that represents raw text content that should be passed directly to the model
    without any template processing or validation
    """

    value: str
    type: Literal['raw_text'] = 'raw_text'


@dataclass(kw_only=True)
class InputMessageContent7:
    """
    Struct that represents a model's reasoning
    """

    type: Literal['thought'] = 'thought'
    text: str | None = None
    signature: str | None = None
    """
    An optional signature - currently, this is only used with Anthropic,
    and is ignored by other providers.
    """
    summary: list[ThoughtSummaryBlock] | None = None
    field_internal_provider_type: str | None = None
    """
    When set, this 'Thought' block will only be used for providers
    matching this type (e.g. `anthropic`). Other providers will emit
    a warning and discard the block.
    """


@dataclass(kw_only=True)
class InputMessageContent8(UrlFile):
    """
    A file for an inference or a datapoint.
    """

    type: Literal['file'] = 'file'


@dataclass(kw_only=True)
class InputMessageContent9(Base64File):
    """
    A file for an inference or a datapoint.
    """

    type: Literal['file'] = 'file'


@dataclass(kw_only=True)
class InputMessageContent10(ObjectStoragePointer):
    """
    A file for an inference or a datapoint.
    """

    type: Literal['file'] = 'file'


@dataclass(kw_only=True)
class InputMessageContent11(ObjectStorageFile):
    """
    A file for an inference or a datapoint.
    """

    type: Literal['file'] = 'file'


@dataclass(kw_only=True)
class InputMessageContent12(ObjectStorageError):
    """
    A file for an inference or a datapoint.
    """

    type: Literal['file'] = 'file'


@dataclass(kw_only=True)
class InputMessageContent13:
    """
    An unknown content block type, used to allow passing provider-specific
    content blocks (e.g. Anthropic's `redacted_thinking`) in and out
    of TensorZero.
    The `data` field holds the original content block from the provider,
    without any validation or transformation by TensorZero.
    """

    data: Any
    """
    The underlying content block to be passed to the model provider.
    """
    type: Literal['unknown'] = 'unknown'
    model_provider_name: str | None = None
    """
    A fully-qualified name specifying when this content block should
    be included in the model provider input.
    """


InputMessageContent = (
    InputMessageContent1
    | InputMessageContent2
    | InputMessageContent3
    | InputMessageContent4
    | InputMessageContent5
    | InputMessageContent6
    | InputMessageContent7
    | InputMessageContent8
    | InputMessageContent9
    | InputMessageContent10
    | InputMessageContent11
    | InputMessageContent12
    | InputMessageContent13
)


ToolCallWrapper = ToolCall | InferenceResponseToolCall


@dataclass(kw_only=True)
class File1:
    """
    A file that can be located at a URL
    """

    url: str
    file_type: Literal['url'] = 'url'
    mime_type: str | None = None
    detail: Detail | None = None


@dataclass(kw_only=True)
class File2:
    """
    A file already encoded as base64
    """

    mime_type: str
    data: str
    file_type: Literal['base64'] = 'base64'
    source_url: str | None = None
    detail: Detail | None = None


@dataclass(kw_only=True)
class File3:
    """
    A file stored in an object storage backend, without data.
    This struct can be stored in the database. It's used by `StoredFile` (`StoredInput`).
    Note: `File` supports both `ObjectStorageFilePointer` and `ObjectStorageFile`.
    """

    mime_type: str
    storage_path: str
    file_type: Literal['object_storage_pointer'] = 'object_storage_pointer'
    source_url: str | None = None
    detail: Detail | None = None


@dataclass(kw_only=True)
class File4:
    """
    A file stored in an object storage backend, with data.
    This struct can NOT be stored in the database.
    Note: `File` supports both `ObjectStorageFilePointer` and `ObjectStorageFile`.
    """

    mime_type: str
    storage_path: str
    data: str
    file_type: Literal['object_storage'] = 'object_storage'
    source_url: str | None = None
    detail: Detail | None = None


@dataclass(kw_only=True)
class File5:
    """
    A file that we failed to read from object storage.
    This struct can NOT be stored in the database.
    """

    mime_type: str
    storage_path: str
    file_type: Literal['object_storage_error'] = 'object_storage_error'
    source_url: str | None = None
    detail: Detail | None = None
    error: str | None = None


File = File1 | File2 | File3 | File4 | File5


@dataclass(kw_only=True)
class NestedMetadata:
    key: str
    value: str


@dataclass(kw_only=True)
class ContentBlockChatOutput1:
    """
    InputMessages are validated against the input schema of the Function
    and then templated and transformed into RequestMessages for a particular Variant.
    They might contain tool calls or tool results along with text.
    The abstraction we use to represent this is ContentBlock, which is a union of Text, ToolCall, and ToolResult.
    ContentBlocks are collected into RequestMessages.
    These RequestMessages are collected into a ModelInferenceRequest,
    which should contain all information needed by a ModelProvider to perform the
    inference that is called for.
    """

    text: str
    type: Literal['text'] = 'text'


@dataclass(kw_only=True)
class ContentBlockChatOutput2:
    """
    An InferenceResponseToolCall is a request by a model to call a Tool
    in the form that we return to the client / ClickHouse
    """

    id: str
    """
    A Tool Call ID to match up with tool call responses. See #4058.
    """
    raw_name: str
    """
    The name of the tool to call, as generated by the model.
    """
    raw_arguments: str
    """
    The raw arguments JSON string of the tool to call, as generated by the model.
    """
    type: Literal['tool_call'] = 'tool_call'
    name: str | None = None
    """
    The name of the tool to call, validated against tool configs. If not present, it means the tool call was invalid.
    """
    arguments: Any | None = None
    """
    The arguments of the tool to call, validated against tool configs. If not present, it means the tool call arguments were invalid.
    """


@dataclass(kw_only=True)
class ContentBlockChatOutput3:
    """
    Struct that represents a model's reasoning
    """

    type: Literal['thought'] = 'thought'
    text: str | None = None
    signature: str | None = None
    """
    An optional signature - currently, this is only used with Anthropic,
    and is ignored by other providers.
    """
    summary: list[ThoughtSummaryBlock] | None = None
    field_internal_provider_type: str | None = None
    """
    When set, this 'Thought' block will only be used for providers
    matching this type (e.g. `anthropic`). Other providers will emit
    a warning and discard the block.
    """


@dataclass(kw_only=True)
class ContentBlockChatOutput4:
    """
    Defines the types of content block that can come from a `chat` function
    """

    data: Any
    type: Literal['unknown'] = 'unknown'
    model_provider_name: str | None = None


ContentBlockChatOutput = (
    ContentBlockChatOutput1
    | ContentBlockChatOutput2
    | ContentBlockChatOutput3
    | ContentBlockChatOutput4
)


@dataclass(kw_only=True)
class DatapointMetadataUpdate:
    """
    A request to update the metadata of a datapoint.
    """

    name: str | None | _UnsetType = UNSET
    """
    Datapoint name. If omitted, it will be left unchanged. If specified as `null`, it will be set to `null`. If specified as a value, it will be set to the provided value.
    """


@dataclass(kw_only=True)
class JsonDatapointOutputUpdate:
    """
    A request to update the output of a JSON datapoint.
    We intentionally only accept the `raw` field (in a JSON-serialized string), because datapoints can contain invalid outputs, and it's desirable
    for users to run evals against them.
    """

    raw: str
    """
    The raw output of the datapoint. For valid JSON outputs, this should be a JSON-serialized string.
    """


@dataclass(kw_only=True)
class ContentBlock1:
    """
    InputMessages are validated against the input schema of the Function
    and then templated and transformed into RequestMessages for a particular Variant.
    They might contain tool calls or tool results along with text.
    The abstraction we use to represent this is ContentBlock, which is a union of Text, ToolCall, and ToolResult.
    ContentBlocks are collected into RequestMessages.
    These RequestMessages are collected into a ModelInferenceRequest,
    which should contain all information needed by a ModelProvider to perform the
    inference that is called for.
    """

    text: str
    type: Literal['text'] = 'text'


@dataclass(kw_only=True)
class ContentBlock2:
    """
    Core representation of the types of content that could go into a model provider
    The `PartialEq` impl will panic if we try to compare a `LazyFile`, so we make it
    test-only to prevent production code from panicking.
    This *does not* implement `Deserialize`, since we need object store information
    to produce a `LazyFile::Url`
    """

    id: str
    name: str
    arguments: str
    type: Literal['tool_call'] = 'tool_call'


@dataclass(kw_only=True)
class ContentBlock3:
    """
    A ToolResult is the outcome of a ToolCall, which we may want to present back to the model
    """

    name: str
    result: str
    id: str
    type: Literal['tool_result'] = 'tool_result'


@dataclass(kw_only=True)
class Url:
    file_url: FileUrl


@dataclass(kw_only=True)
class ContentBlock4:
    """
    Core representation of the types of content that could go into a model provider
    The `PartialEq` impl will panic if we try to compare a `LazyFile`, so we make it
    test-only to prevent production code from panicking.
    This *does not* implement `Deserialize`, since we need object store information
    to produce a `LazyFile::Url`
    """

    type: Literal['file'] = 'file'
    Url: Url


@dataclass(kw_only=True)
class ObjectStoragePointer1:
    metadata: Base64FileMetadata
    storage_path: str


@dataclass(kw_only=True)
class ContentBlock6:
    """
    Core representation of the types of content that could go into a model provider
    The `PartialEq` impl will panic if we try to compare a `LazyFile`, so we make it
    test-only to prevent production code from panicking.
    This *does not* implement `Deserialize`, since we need object store information
    to produce a `LazyFile::Url`
    """

    type: Literal['file'] = 'file'
    ObjectStoragePointer: ObjectStoragePointer1


@dataclass(kw_only=True)
class ContentBlock7:
    """
    Core representation of the types of content that could go into a model provider
    The `PartialEq` impl will panic if we try to compare a `LazyFile`, so we make it
    test-only to prevent production code from panicking.
    This *does not* implement `Deserialize`, since we need object store information
    to produce a `LazyFile::Url`
    """

    type: Literal['file'] = 'file'
    ObjectStorage: ObjectStorageFile


@dataclass(kw_only=True)
class ContentBlock8:
    """
    Struct that represents a model's reasoning
    """

    type: Literal['thought'] = 'thought'
    text: str | None = None
    signature: str | None = None
    """
    An optional signature - currently, this is only used with Anthropic,
    and is ignored by other providers.
    """
    summary: list[ThoughtSummaryBlock] | None = None
    field_internal_provider_type: str | None = None
    """
    When set, this 'Thought' block will only be used for providers
    matching this type (e.g. `anthropic`). Other providers will emit
    a warning and discard the block.
    """


@dataclass(kw_only=True)
class ContentBlock9:
    """
    Represents an unknown provider-specific content block.
    We pass this along as-is without any validation or transformation.
    """

    data: Any
    """
    The underlying content block to be passed to the model provider.
    """
    type: Literal['unknown'] = 'unknown'
    model_provider_name: str | None = None
    """
    A fully-qualified name specifying when this content block should
    be included in the model provider input.
    E.g `tensorzero::model_name::claude-3-7-sonnet-20250219-thinking::provider_name::anthropic-extra-body`

    If set to `Some`, this is compared against the output of `fully_qualified_name` before invoking
    a model provider, and stripped from the input if it doesn't match.
    If set to `None, then this is passed to all model providers.
    Individual model provider implementation never need to check this field themselves -
    they only need to produce it with the proper `fully_qualified_name` set.
    """


@dataclass(kw_only=True)
class DoubleOptionalExample:
    """
    Example type demonstrating Option<Option<T>> with custom annotations

    This showcases how to use #[schemars(extend(...))] to add custom
    vendor extensions (x-* fields) to the generated JSON schema.
    """

    simple_optional: str | None = None
    """
    A regular optional field (single Option)
    """
    double_optional: str | None | _UnsetType = UNSET
    """
    A double-optional field with custom annotation

    The outer Option represents "field may be absent"
    The inner Option represents "field may be explicitly null"

    Custom annotation "x-double-optional" marks this for special handling
    """
    annotated_field: int | None | _UnsetType = UNSET
    """
    Another double-optional with multiple custom annotations
    """


@dataclass(kw_only=True)
class LazyFile1:
    Url: Url


@dataclass(kw_only=True)
class LazyFile3:
    ObjectStoragePointer: ObjectStoragePointer1


@dataclass(kw_only=True)
class LazyFile4:
    ObjectStorage: ObjectStorageFile


@dataclass(kw_only=True)
class NestedOptionalExample:
    """
    Example with nested structures
    """

    name: str
    metadata: NestedMetadata | None | _UnsetType = UNSET


@dataclass(kw_only=True)
class RawText:
    """
    Struct that represents raw text content that should be passed directly to the model
    without any template processing or validation
    """

    value: str


@dataclass(kw_only=True)
class Template:
    name: str
    arguments: Arguments


@dataclass(kw_only=True)
class Text:
    """
    InputMessages are validated against the input schema of the Function
    and then templated and transformed into RequestMessages for a particular Variant.
    They might contain tool calls or tool results along with text.
    The abstraction we use to represent this is ContentBlock, which is a union of Text, ToolCall, and ToolResult.
    ContentBlocks are collected into RequestMessages.
    These RequestMessages are collected into a ModelInferenceRequest,
    which should contain all information needed by a ModelProvider to perform the
    inference that is called for.
    """

    text: str


@dataclass(kw_only=True)
class ToolCallChunk:
    id: str
    raw_arguments: str
    raw_name: str | None = None


@dataclass(kw_only=True)
class ToolResult:
    """
    A ToolResult is the outcome of a ToolCall, which we may want to present back to the model
    """

    name: str
    result: str
    id: str


@dataclass(kw_only=True)
class TransformExample:
    """
    Example showing a transform function approach
    """

    regular_field: str
    double_optional_field: bool | None = None


@dataclass(kw_only=True)
class Unknown:
    """
    Struct that represents an unknown provider-specific content block.
    We pass this along as-is without any validation or transformation.
    """

    data: Any
    """
    The underlying content block to be passed to the model provider.
    """
    model_provider_name: str | None = None
    """
    A fully-qualified name specifying when this content block should
    be included in the model provider input.
    """


@dataclass(kw_only=True)
class UpdateDatapointsResponse:
    """
    A response to a request to update one or more datapoints in a dataset.
    """

    ids: list[str]
    """
    The IDs of the datapoints that were updated.
    These are newly generated IDs for UpdateDatapoint requests, and they are the same IDs for UpdateDatapointMetadata requests.
    """


PendingObjectStoreFile = ObjectStorageFile


@dataclass(kw_only=True)
class ProviderTool:
    tool: Any
    scope: ProviderToolScope | None = None


System = str | Arguments


@dataclass(kw_only=True)
class InputMessage:
    """
    InputMessage and Role are our representation of the input sent by the client
    prior to any processing into LLM representations below.
    `InputMessage` has a custom deserializer that addresses legacy data formats that we used to support (see input_message.rs).
    """

    role: Role
    content: list[InputMessageContent]


@dataclass(kw_only=True)
class Input:
    """
    A request is made that contains an Input
    """

    system: System | None = None
    messages: list[InputMessage] | None = field(default_factory=lambda: [])


@dataclass(kw_only=True)
class DynamicToolParams:
    """
    Wire/API representation of dynamic tool parameters for inference requests.

    This type is the **wire format** for tool configurations used in API requests and responses.
    It distinguishes between static tools (configured in the function) and dynamic tools
    (provided at runtime), allowing clients to reference pre-configured tools by name or
    provide new tools on-the-fly.

    # Purpose
    - Accept tool parameters in inference API requests (e.g., `/inference/{function_name}`)
    - Expose tool configurations in API responses for stored inferences
    - Support Python and TypeScript client bindings
    - Allow runtime customization of tool behavior

    # Fields
    - `allowed_tools`: Names of static tools from function config to use (subset selection)
    - `additional_tools`: New tools defined at runtime (not in static config)
    - `tool_choice`: Override the function's default tool choice strategy
    - `parallel_tool_calls`: Override whether parallel tool calls are enabled
    - `provider_tools`: Provider-specific tool configurations (not persisted to database)

    # Key Differences from ToolCallConfigDatabaseInsert
    - **Separate lists**: Maintains distinction between static (`allowed_tools`) and dynamic (`additional_tools`) tools
    - **By reference**: Static tools referenced by name, not duplicated
    - **Has provider_tools**: Can specify provider-specific tool configurations
    - **Has bindings**: Exposed to Python/TypeScript via `pyo3` and `ts_rs`

    # Conversion to Storage Format
    Converting from `DynamicToolParams` to `ToolCallConfigDatabaseInsert` is a **lossy** operation:
    1. Static tools (from `allowed_tools` names) are resolved from function config
    2. Dynamic tools (from `additional_tools`) are included as-is
    3. Both lists are merged into a single `tools_available` list
    4. The distinction between static and dynamic tools is lost
    5. `provider_tools` are dropped (not stored)

    Use `FunctionConfig::dynamic_tool_params_to_database_insert()` for this conversion.

    # Conversion from Storage Format
    Converting from `ToolCallConfigDatabaseInsert` back to `DynamicToolParams` attempts to reconstruct the original:
    1. Tools that match function config tool names → `allowed_tools`
    2. Tools that don't match function config → `additional_tools`
    3. `provider_tools` is set to `None` (cannot be recovered)

    Use `FunctionConfig::database_insert_to_dynamic_tool_params()` for this conversion.

    # Example
    ```rust,ignore
    // API request with dynamic tool params
    let params = DynamicToolParams {
        allowed_tools: Some(vec!["calculator".to_string()]),  // Use only the calculator tool from config
        additional_tools: Some(vec![Tool {  runtime tool  }]),  // Add a new tool
        tool_choice: Some(ToolChoice::Required),
        parallel_tool_calls: Some(true),
        provider_tools: None,
    };

    // Convert to storage format (merge tools, lose distinction)
    let db_insert = function_config
        .dynamic_tool_params_to_database_insert(params, &static_tools)?
        .unwrap_or_default();

    // db_insert.tools_available now contains both the calculator tool (from config)
    // and the runtime tool (from additional_tools), merged together
    ```

    See also: [`ToolCallConfigDatabaseInsert`] for the storage/database format
    """

    allowed_tools: list[str] | None = None
    """
    A subset of static tools configured for the function that the inference is allowed to use. Optional.
    If not provided, all static tools are allowed.
    """
    additional_tools: list[Tool] | None = None
    """
    Tools that the user provided at inference time (not in function config), in addition to the function-configured
    tools, that are also allowed.
    """
    tool_choice: ToolChoice | None = None
    """
    User-specified tool choice strategy. If provided during inference, it will override the function-configured tool choice.
    Optional.
    """
    parallel_tool_calls: bool | None = None
    """
    Whether to use parallel tool calls in the inference. Optional.
    If provided during inference, it will override the function-configured parallel tool calls.
    """
    provider_tools: list[ProviderTool] | None = None
    """
    Provider-specific tool configurations (not persisted to database)
    """


@dataclass(kw_only=True)
class UpdateChatDatapointRequest:
    """
    An update request for a chat datapoint.
    For any fields that are optional in ChatInferenceDatapoint, the request field distinguishes between an omitted field, `null`, and a value:
    - If the field is omitted, it will be left unchanged.
    - If the field is specified as `null`, it will be set to `null`.
    - If the field has a value, it will be set to the provided value.

    In Rust this is modeled as an `Option<Option<T>>`, where `None` means "unchanged" and `Some(None)` means "set to `null`" and `Some(Some(T))` means "set to the provided value".
    """

    id: str
    """
    The ID of the datapoint to update. Required.
    """
    input: Input | None = None
    """
    Datapoint input. If omitted, it will be left unchanged.
    """
    output: list[ContentBlockChatOutput] | None = None
    """
    Chat datapoint output. If omitted, it will be left unchanged. If empty, it will be cleared. Otherwise,
    it will overwrite the existing output.
    """
    tool_params: DynamicToolParams | None = None
    """
    Datapoint tool parameters. If omitted, it will be left unchanged. If specified as `null`, it will be set to `null`. If specified as a value, it will be set to the provided value.
    """
    tags: dict[str, Any] | None = None
    """
    Datapoint tags. If omitted, it will be left unchanged. If empty, it will be cleared. Otherwise,
    it will be overwrite the existing tags.
    """
    metadata: DatapointMetadataUpdate | None = None
    """
    Metadata fields. If omitted, it will be left unchanged.
    """


@dataclass(kw_only=True)
class UpdateJsonDatapointRequest:
    """
    An update request for a JSON datapoint.
    For any fields that are optional in JsonInferenceDatapoint, the request field distinguishes between an omitted field, `null`, and a value:
    - If the field is omitted, it will be left unchanged.
    - If the field is specified as `null`, it will be set to `null`.
    - If the field has a value, it will be set to the provided value.

    In Rust this is modeled as an `Option<Option<T>>`, where `None` means "unchanged" and `Some(None)` means "set to `null`" and `Some(Some(T))` means "set to the provided value".
    """

    id: str
    """
    The ID of the datapoint to update. Required.
    """
    input: Input | None = None
    """
    Datapoint input. If omitted, it will be left unchanged.
    """
    output: JsonDatapointOutputUpdate | None = None
    """
    JSON datapoint output. If omitted, it will be left unchanged. If `null`, it will be set to `null`. If specified as a value, it will be set to the provided value.
    This will be parsed and validated against output_schema, and valid `raw` values will be parsed and stored as `parsed`. Invalid `raw` values will
    also be stored, because we allow invalid outputs in datapoints by design.
    """
    output_schema: Any | None = None
    """
    The output schema of the JSON datapoint. If omitted, it will be left unchanged. If specified as `null`, it will be set to `null`. If specified as a value, it will be set to the provided value.
    If not provided, the function's output schema will be used.
    """
    tags: dict[str, Any] | None = None
    """
    Datapoint tags. If omitted, it will be left unchanged. If empty, it will be cleared. Otherwise,
    it will be overwrite the existing tags.
    """
    metadata: DatapointMetadataUpdate | None = None
    """
    Metadata fields. If omitted, it will be left unchanged.
    """


@dataclass(kw_only=True)
class UpdateDatapointRequest1:
    """
    Request to update a chat datapoint.
    """

    id: str
    """
    The ID of the datapoint to update. Required.
    """
    type: Literal['chat'] = 'chat'
    input: Input | None = None
    """
    Datapoint input. If omitted, it will be left unchanged.
    """
    output: list[ContentBlockChatOutput] | None = None
    """
    Chat datapoint output. If omitted, it will be left unchanged. If empty, it will be cleared. Otherwise,
    it will overwrite the existing output.
    """
    tool_params: DynamicToolParams | None = None
    """
    Datapoint tool parameters. If omitted, it will be left unchanged. If specified as `null`, it will be set to `null`. If specified as a value, it will be set to the provided value.
    """
    tags: dict[str, Any] | None = None
    """
    Datapoint tags. If omitted, it will be left unchanged. If empty, it will be cleared. Otherwise,
    it will be overwrite the existing tags.
    """
    metadata: DatapointMetadataUpdate | None = None
    """
    Metadata fields. If omitted, it will be left unchanged.
    """


@dataclass(kw_only=True)
class UpdateDatapointRequest2:
    """
    Request to update a JSON datapoint.
    """

    id: str
    """
    The ID of the datapoint to update. Required.
    """
    type: Literal['json'] = 'json'
    input: Input | None = None
    """
    Datapoint input. If omitted, it will be left unchanged.
    """
    output: JsonDatapointOutputUpdate | None = None
    """
    JSON datapoint output. If omitted, it will be left unchanged. If `null`, it will be set to `null`. If specified as a value, it will be set to the provided value.
    This will be parsed and validated against output_schema, and valid `raw` values will be parsed and stored as `parsed`. Invalid `raw` values will
    also be stored, because we allow invalid outputs in datapoints by design.
    """
    output_schema: Any | None = None
    """
    The output schema of the JSON datapoint. If omitted, it will be left unchanged. If specified as `null`, it will be set to `null`. If specified as a value, it will be set to the provided value.
    If not provided, the function's output schema will be used.
    """
    tags: dict[str, Any] | None = None
    """
    Datapoint tags. If omitted, it will be left unchanged. If empty, it will be cleared. Otherwise,
    it will be overwrite the existing tags.
    """
    metadata: DatapointMetadataUpdate | None = None
    """
    Metadata fields. If omitted, it will be left unchanged.
    """


UpdateDatapointRequest = UpdateDatapointRequest1 | UpdateDatapointRequest2


@dataclass(kw_only=True)
class ContentBlock5:
    """
    Core representation of the types of content that could go into a model provider
    The `PartialEq` impl will panic if we try to compare a `LazyFile`, so we make it
    test-only to prevent production code from panicking.
    This *does not* implement `Deserialize`, since we need object store information
    to produce a `LazyFile::Url`
    """

    type: Literal['file'] = 'file'
    Base64: PendingObjectStoreFile


ContentBlock = (
    ContentBlock1
    | ContentBlock2
    | ContentBlock3
    | ContentBlock4
    | ContentBlock5
    | ContentBlock6
    | ContentBlock7
    | ContentBlock8
    | ContentBlock9
)


@dataclass(kw_only=True)
class LazyFile2:
    Base64: PendingObjectStoreFile


LazyFile = LazyFile1 | LazyFile2 | LazyFile3 | LazyFile4


@dataclass(kw_only=True)
class UpdateDatapointsRequest:
    """
    Request to update one or more datapoints in a dataset.
    """

    datapoints: list[UpdateDatapointRequest]
    """
    The datapoints to update.
    """
